<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="light-mode">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=9" />
        <meta name="generator" content="Doxygen 1.9.8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>ampsci:
            qip Namespace Reference</title>
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="blue-theme.css" rel="stylesheet" type="text/css"/>
        <!-- ... other metadata & script includes ... -->
        <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeFragmentCopyButton.init()
        </script>
        <!-- <script>
            document.documentElement.classList.add("light-mode");
        </script> -->
    </head>
    <body>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div id="titlearea">
                <table cellspacing="0" cellpadding="0">
                    <tbody>
                        <tr style="height: 56px;">
                            <td id="projectalign" style="padding-left: 0.5em;">
                                <div id="projectname">ampsci
                                </div>
                                <div
                                    id="projectbrief">High-precision calculations for one- and two-valence atomic systems</div>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceqip.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">qip Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>qip library: A collection of useful functions  
<a href="namespaceqip.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceqip_1_1overloads" id="r_namespaceqip_1_1overloads"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip_1_1overloads.html">overloads</a></td></tr>
<tr class="memdesc:namespaceqip_1_1overloads"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace qip::overloads provides operator overloads for std::vector <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqip_1_1Arithmetic.html">Arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for Arithmetic operations. Derive from this to provide +,-,*,/, given +=, -=, *=, /=.  <a href="classqip_1_1Arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqip_1_1Arithmetic2.html">Arithmetic2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for Arithmetic operations. Derive from this to provide +,-,*,/, given +=, -=, *=, /=. Works for two different types.  <a href="classqip_1_1Arithmetic2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqip_1_1ArrayView.html">ArrayView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A view onto a 1D array; used for rows/collumns of ND array. Can have a stride.  <a href="classqip_1_1ArrayView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqip_1_1Comparison.html">Comparison</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for comparisons. Derive from this to provide !=,&gt;,&lt;=,&gt;=, given == and &lt;.  <a href="classqip_1_1Comparison.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqip_1_1ConstStrideIterator.html">ConstStrideIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant iterator accounting for a stride.  <a href="classqip_1_1ConstStrideIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqip_1_1less__abs.html">less_abs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons of absolute values (uses std::abs). Works similarly to std::less.  <a href="structqip_1_1less__abs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqip_1_1StrideIterator.html">StrideIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator accounting for a stride.  <a href="classqip_1_1StrideIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqip_1_1StrongType.html">StrongType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A light-weight easy-to-use single-file header-only template class for strong typing.  <a href="structqip_1_1StrongType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaaf20d224ad6ef434bb4422ee160ef55" id="r_aaaf20d224ad6ef434bb4422ee160ef55"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aaaf20d224ad6ef434bb4422ee160ef55"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aaaf20d224ad6ef434bb4422ee160ef55">product</a> (T first, Args... rest)</td></tr>
<tr class="memdesc:aaaf20d224ad6ef434bb4422ee160ef55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic product - helper function.  <br /></td></tr>
<tr class="separator:aaaf20d224ad6ef434bb4422ee160ef55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c01c7dc9d4b4836f98b46e8779f9f0b" id="r_a9c01c7dc9d4b4836f98b46e8779f9f0b"><td class="memTemplParams" colspan="2"><a id="a9c01c7dc9d4b4836f98b46e8779f9f0b" name="a9c01c7dc9d4b4836f98b46e8779f9f0b"></a>
template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a9c01c7dc9d4b4836f98b46e8779f9f0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NDrange_impl</b> (std::vector&lt; std::array&lt; std::size_t, N &gt; &gt; &amp;result, std::array&lt; std::size_t, N &gt; &amp;current, const std::array&lt; std::size_t, N &gt; &amp;maxValues, std::size_t index)</td></tr>
<tr class="separator:a9c01c7dc9d4b4836f98b46e8779f9f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bffe52945e07e097fb95f9877e12a79" id="r_a3bffe52945e07e097fb95f9877e12a79"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3bffe52945e07e097fb95f9877e12a79"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a3bffe52945e07e097fb95f9877e12a79">NDrange</a> (std::size_t first, Args... rest)</td></tr>
<tr class="memdesc:a3bffe52945e07e097fb95f9877e12a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic array of all possible indexes.  <br /></td></tr>
<tr class="separator:a3bffe52945e07e097fb95f9877e12a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa8ce8b7b2ea7201cf954b9c52cc2dd" id="r_a2fa8ce8b7b2ea7201cf954b9c52cc2dd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a2fa8ce8b7b2ea7201cf954b9c52cc2dd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a2fa8ce8b7b2ea7201cf954b9c52cc2dd">max</a> (T first, Args... rest)</td></tr>
<tr class="memdesc:a2fa8ce8b7b2ea7201cf954b9c52cc2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum of any number of parameters (variadic function)  <br /></td></tr>
<tr class="separator:a2fa8ce8b7b2ea7201cf954b9c52cc2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e81dfdf0cd840d0ead840f72a066be" id="r_aa9e81dfdf0cd840d0ead840f72a066be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aa9e81dfdf0cd840d0ead840f72a066be"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aa9e81dfdf0cd840d0ead840f72a066be">min</a> (T first, Args... rest)</td></tr>
<tr class="memdesc:aa9e81dfdf0cd840d0ead840f72a066be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns minimum of any number of parameters (variadic function)  <br /></td></tr>
<tr class="separator:aa9e81dfdf0cd840d0ead840f72a066be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b99af2e2e2a1d9438a995c2555f51e" id="r_a80b99af2e2e2a1d9438a995c2555f51e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a80b99af2e2e2a1d9438a995c2555f51e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a80b99af2e2e2a1d9438a995c2555f51e">max_abs</a> (T first, Args... rest)</td></tr>
<tr class="memdesc:a80b99af2e2e2a1d9438a995c2555f51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value with maximum absolute value of any number of parameters (variadic function)  <br /></td></tr>
<tr class="separator:a80b99af2e2e2a1d9438a995c2555f51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2670fff7c6536bb13a8d677336e72fb" id="r_ac2670fff7c6536bb13a8d677336e72fb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ac2670fff7c6536bb13a8d677336e72fb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ac2670fff7c6536bb13a8d677336e72fb">min_abs</a> (T first, Args... rest)</td></tr>
<tr class="memdesc:ac2670fff7c6536bb13a8d677336e72fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value with minimum absolute value of any number of parameters (variadic function)  <br /></td></tr>
<tr class="separator:ac2670fff7c6536bb13a8d677336e72fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe1bfb56638d7c8dccdff2d6b8f07ad" id="r_a1fe1bfb56638d7c8dccdff2d6b8f07ad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a1fe1bfb56638d7c8dccdff2d6b8f07ad"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a1fe1bfb56638d7c8dccdff2d6b8f07ad">max_difference</a> (T first, Args... rest)</td></tr>
<tr class="memdesc:a1fe1bfb56638d7c8dccdff2d6b8f07ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max{args..} - min{args...}, for any number of args (variadic)  <br /></td></tr>
<tr class="separator:a1fe1bfb56638d7c8dccdff2d6b8f07ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93902898009ff74b7ff28f72ba7bcf2" id="r_ae93902898009ff74b7ff28f72ba7bcf2"><td class="memTemplParams" colspan="2">template&lt;int n, typename T &gt; </td></tr>
<tr class="memitem:ae93902898009ff74b7ff28f72ba7bcf2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ae93902898009ff74b7ff28f72ba7bcf2">pow</a> (T x)</td></tr>
<tr class="memdesc:ae93902898009ff74b7ff28f72ba7bcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">x^n for integer n (n compile-time template parameter), x any arithmetic type (T). Returns double for inverse powers, T otherwise  <br /></td></tr>
<tr class="separator:ae93902898009ff74b7ff28f72ba7bcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5f2fdede884dd745ce55f2da0f5d7d" id="r_a9d5f2fdede884dd745ce55f2da0f5d7d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d5f2fdede884dd745ce55f2da0f5d7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a9d5f2fdede884dd745ce55f2da0f5d7d">pow</a> (T x, int n)</td></tr>
<tr class="memdesc:a9d5f2fdede884dd745ce55f2da0f5d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">x^n for integer n (runtime n), x any floating point type (T).  <br /></td></tr>
<tr class="separator:a9d5f2fdede884dd745ce55f2da0f5d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1353142288a3dea2be6eeedbe241e0b" id="r_aa1353142288a3dea2be6eeedbe241e0b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa1353142288a3dea2be6eeedbe241e0b"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aa1353142288a3dea2be6eeedbe241e0b">factorial</a> (T x)</td></tr>
<tr class="memdesc:aa1353142288a3dea2be6eeedbe241e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorial x! - nb: does not check for overflow. Max x is 20 for uint64_t. Note: returns 1 for arguments &lt;0.  <br /></td></tr>
<tr class="separator:aa1353142288a3dea2be6eeedbe241e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1569a13a7405afcf571cbac822eab9d2" id="r_a1569a13a7405afcf571cbac822eab9d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1569a13a7405afcf571cbac822eab9d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a1569a13a7405afcf571cbac822eab9d2">double_factorial</a> (T x)</td></tr>
<tr class="memdesc:a1569a13a7405afcf571cbac822eab9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double factorial x!! - nb: does not check for overflow. Max x is 20 for uint64_t.  <br /></td></tr>
<tr class="separator:a1569a13a7405afcf571cbac822eab9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762e6d5bf39ffca404e2d778fafbb0d9" id="r_a762e6d5bf39ffca404e2d778fafbb0d9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a762e6d5bf39ffca404e2d778fafbb0d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a762e6d5bf39ffca404e2d778fafbb0d9">sign</a> (T value)</td></tr>
<tr class="memdesc:a762e6d5bf39ffca404e2d778fafbb0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sign of value. Note: sign(0)==0.  <br /></td></tr>
<tr class="separator:a762e6d5bf39ffca404e2d778fafbb0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af091ad44ba19b2538888cf9487af0e31" id="r_af091ad44ba19b2538888cf9487af0e31"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af091ad44ba19b2538888cf9487af0e31"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#af091ad44ba19b2538888cf9487af0e31">clip</a> (T value, T <a class="el" href="namespaceqip.html#a80b99af2e2e2a1d9438a995c2555f51e">max_abs</a>)</td></tr>
<tr class="memdesc:af091ad44ba19b2538888cf9487af0e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clips value to between -max &lt;= value &lt;= max clip(x,max) : |x| &gt; max, ret max; if |x|&lt;-max, -max; else x.  <br /></td></tr>
<tr class="separator:af091ad44ba19b2538888cf9487af0e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62de3c5b336d174e02feabf709867f3" id="r_ab62de3c5b336d174e02feabf709867f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab62de3c5b336d174e02feabf709867f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ab62de3c5b336d174e02feabf709867f3">chop</a> (T value, T <a class="el" href="namespaceqip.html#ac2670fff7c6536bb13a8d677336e72fb">min_abs</a>)</td></tr>
<tr class="memdesc:ab62de3c5b336d174e02feabf709867f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets values |v|&lt;min to zero; if |v|&gt;=min, returns v.  <br /></td></tr>
<tr class="separator:ab62de3c5b336d174e02feabf709867f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577a0e5927c5e966a43237a627fa3824" id="r_a577a0e5927c5e966a43237a627fa3824"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Real &gt; </td></tr>
<tr class="memitem:a577a0e5927c5e966a43237a627fa3824"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Real, Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a577a0e5927c5e966a43237a627fa3824">derivative</a> (Function y, Real x, Real delta_target=Real{1.0e-6}, Real dx=Real{0.01}, unsigned it_limit=250)</td></tr>
<tr class="memdesc:a577a0e5927c5e966a43237a627fa3824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slow, but accurate, method of finding derivative of function (y) at a point (x). Returns derivative + error estimate.  <br /></td></tr>
<tr class="separator:a577a0e5927c5e966a43237a627fa3824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741388b88ce35a381243800765e5dc7c" id="r_a741388b88ce35a381243800765e5dc7c"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Real &gt; </td></tr>
<tr class="memitem:a741388b88ce35a381243800765e5dc7c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Real, Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a741388b88ce35a381243800765e5dc7c">Newtons</a> (Function f, Real x, Real delta_target=Real{1.0e-6}, Real dx=Real{0.01}, unsigned it_limit=250)</td></tr>
<tr class="memdesc:a741388b88ce35a381243800765e5dc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve f(x) = 0 for x using Newtons method. Returns root + error estimate/.  <br /></td></tr>
<tr class="separator:a741388b88ce35a381243800765e5dc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d843d875d5c96318cf4cb71057832d" id="r_a60d843d875d5c96318cf4cb71057832d"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Real &gt; </td></tr>
<tr class="memitem:a60d843d875d5c96318cf4cb71057832d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Real, Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a60d843d875d5c96318cf4cb71057832d">Newtons</a> (Function f, Real x, std::pair&lt; Real, Real &gt; bounds, Real delta_target=Real{1.0e-6}, Real dx=Real{0.01}, unsigned it_limit=250)</td></tr>
<tr class="memdesc:a60d843d875d5c96318cf4cb71057832d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve f(x) = 0 for x using Newtons method. Returns root + error estimate. Enforced to be between bounds.  <br /></td></tr>
<tr class="separator:a60d843d875d5c96318cf4cb71057832d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace80c89c04a21d525dc9242303bf1ef8" id="r_ace80c89c04a21d525dc9242303bf1ef8"><td class="memItemLeft" align="right" valign="top"><a id="ace80c89c04a21d525dc9242303bf1ef8" name="ace80c89c04a21d525dc9242303bf1ef8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>omp_details</b> ()</td></tr>
<tr class="separator:ace80c89c04a21d525dc9242303bf1ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cac1e9173a8f0ab589e7aa127e7edcd" id="r_a3cac1e9173a8f0ab589e7aa127e7edcd"><td class="memItemLeft" align="right" valign="top"><a id="a3cac1e9173a8f0ab589e7aa127e7edcd" name="a3cac1e9173a8f0ab589e7aa127e7edcd"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>random_string</b> (std::size_t length)</td></tr>
<tr class="separator:a3cac1e9173a8f0ab589e7aa127e7edcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95825e5328321b8e0f83c230a42bd384" id="r_a95825e5328321b8e0f83c230a42bd384"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a95825e5328321b8e0f83c230a42bd384">fstring</a> (const std::string format,...)</td></tr>
<tr class="memdesc:a95825e5328321b8e0f83c230a42bd384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a formatted std::string, with formatting printf-like commands. Note: maximum string lenth is 256 characters. If longer string required, use provided overload.  <br /></td></tr>
<tr class="separator:a95825e5328321b8e0f83c230a42bd384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f77c0373bce44b37d7e26af0f03de4" id="r_a97f77c0373bce44b37d7e26af0f03de4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a97f77c0373bce44b37d7e26af0f03de4">fstring</a> (const std::size_t size, const std::string format,...)</td></tr>
<tr class="memdesc:a97f77c0373bce44b37d7e26af0f03de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload: size is maximum string length (buffer size).  <br /></td></tr>
<tr class="separator:a97f77c0373bce44b37d7e26af0f03de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6b3539250c3e8aec56e34d8588fb15" id="r_aae6b3539250c3e8aec56e34d8588fb15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aae6b3539250c3e8aec56e34d8588fb15">wildcard_compare</a> (std::string_view s1, std::string_view s2)</td></tr>
<tr class="memdesc:aae6b3539250c3e8aec56e34d8588fb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings, s1 and s2. s2 may contain ONE wildcard ('*') which will match anything.  <br /></td></tr>
<tr class="separator:aae6b3539250c3e8aec56e34d8588fb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0c485769c3134b6746de97235628d7" id="r_aec0c485769c3134b6746de97235628d7"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aec0c485769c3134b6746de97235628d7">tolower</a> (char ch)</td></tr>
<tr class="memdesc:aec0c485769c3134b6746de97235628d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">return static_cast&lt;char&gt;(std::tolower(static_cast&lt;unsigned char&gt;(ch)));  <br /></td></tr>
<tr class="separator:aec0c485769c3134b6746de97235628d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173879a91c1030b2ba5fa0fddd019a88" id="r_a173879a91c1030b2ba5fa0fddd019a88"><td class="memItemLeft" align="right" valign="top"><a id="a173879a91c1030b2ba5fa0fddd019a88" name="a173879a91c1030b2ba5fa0fddd019a88"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>tolower</b> (std::string t_string)</td></tr>
<tr class="separator:a173879a91c1030b2ba5fa0fddd019a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7576d85706d41db6a1c8ca472866dc" id="r_abb7576d85706d41db6a1c8ca472866dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#abb7576d85706d41db6a1c8ca472866dc">contains</a> (std::string_view the_string, std::string_view sub_string)</td></tr>
<tr class="memdesc:abb7576d85706d41db6a1c8ca472866dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the_string (arg1) constaints sub_string (arg2)  <br /></td></tr>
<tr class="separator:abb7576d85706d41db6a1c8ca472866dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a6c501f456cc229942b577ba0347aa" id="r_a52a6c501f456cc229942b577ba0347aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a52a6c501f456cc229942b577ba0347aa">ci_contains</a> (const std::string &amp;the_string, const std::string &amp;sub_string)</td></tr>
<tr class="memdesc:a52a6c501f456cc229942b577ba0347aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the_string (arg1) constaints sub_string (arg2), case insensitive.  <br /></td></tr>
<tr class="separator:a52a6c501f456cc229942b577ba0347aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0e908b7ea1a3aae2063dff50e670de" id="r_a2b0e908b7ea1a3aae2063dff50e670de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a2b0e908b7ea1a3aae2063dff50e670de">contains</a> (const std::string &amp;the_string, const std::vector&lt; std::string &gt; &amp;sub_strings)</td></tr>
<tr class="memdesc:a2b0e908b7ea1a3aae2063dff50e670de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the_string (arg1) constaints any of the sub_strings (arg2)  <br /></td></tr>
<tr class="separator:a2b0e908b7ea1a3aae2063dff50e670de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981f2e3696ed3fea34d7358cb3325679" id="r_a981f2e3696ed3fea34d7358cb3325679"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a981f2e3696ed3fea34d7358cb3325679">ci_contains</a> (const std::string &amp;the_string, const std::vector&lt; std::string &gt; &amp;sub_strings)</td></tr>
<tr class="memdesc:a981f2e3696ed3fea34d7358cb3325679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the_string (arg1) constaints any of the sub_strings (arg2), case insensitive.  <br /></td></tr>
<tr class="separator:a981f2e3696ed3fea34d7358cb3325679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964aa73cc730e146911083bbf6828a41" id="r_a964aa73cc730e146911083bbf6828a41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a964aa73cc730e146911083bbf6828a41">ci_compare</a> (std::string_view s1, std::string_view s2)</td></tr>
<tr class="memdesc:a964aa73cc730e146911083bbf6828a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case insensitive string compare. Essentially: LowerCase(s1)==LowerCase(s2)  <br /></td></tr>
<tr class="separator:a964aa73cc730e146911083bbf6828a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea76ebd33dccecb8ded6e3b3ba447bc" id="r_a7ea76ebd33dccecb8ded6e3b3ba447bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a7ea76ebd33dccecb8ded6e3b3ba447bc">ci_wc_compare</a> (std::string_view s1, std::string_view s2)</td></tr>
<tr class="memdesc:a7ea76ebd33dccecb8ded6e3b3ba447bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings, s1 and s2. s2 may contain ONE wildcard ('*') which will match anything. Case Insensitive version.  <br /></td></tr>
<tr class="separator:a7ea76ebd33dccecb8ded6e3b3ba447bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a229fdb6b5d87ccda7d872052a8072b" id="r_a2a229fdb6b5d87ccda7d872052a8072b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a2a229fdb6b5d87ccda7d872052a8072b">Levenstein</a> (std::string_view a, std::string_view b)</td></tr>
<tr class="memdesc:a2a229fdb6b5d87ccda7d872052a8072b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple non-optimised implementation of the Levenshtein distance.  <br /></td></tr>
<tr class="separator:a2a229fdb6b5d87ccda7d872052a8072b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7591544d632a747d922c0968a18a1482" id="r_a7591544d632a747d922c0968a18a1482"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a7591544d632a747d922c0968a18a1482">ci_Levenstein</a> (std::string_view a, std::string_view b)</td></tr>
<tr class="memdesc:a7591544d632a747d922c0968a18a1482"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple non-optimised implementation of the Levenshtein distance (case insensitive)  <br /></td></tr>
<tr class="separator:a7591544d632a747d922c0968a18a1482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c662c083f1a052ac4ef6d5e3cd4a90d" id="r_a0c662c083f1a052ac4ef6d5e3cd4a90d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a0c662c083f1a052ac4ef6d5e3cd4a90d">closest_match</a> (std::string_view test_string, const std::vector&lt; std::string &gt; &amp;list)</td></tr>
<tr class="memdesc:a0c662c083f1a052ac4ef6d5e3cd4a90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the closest match in list to test_string (return iterator)  <br /></td></tr>
<tr class="separator:a0c662c083f1a052ac4ef6d5e3cd4a90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf877c3d7f4589f0c680e22640e821b5" id="r_acf877c3d7f4589f0c680e22640e821b5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#acf877c3d7f4589f0c680e22640e821b5">ci_closest_match</a> (std::string_view test_string, const std::vector&lt; std::string &gt; &amp;list)</td></tr>
<tr class="memdesc:acf877c3d7f4589f0c680e22640e821b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the closest match (case insensitive) in list to test_string (return iterator)  <br /></td></tr>
<tr class="separator:acf877c3d7f4589f0c680e22640e821b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4980b240c34b6656b3653bd5e41e37a1" id="r_a4980b240c34b6656b3653bd5e41e37a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a4980b240c34b6656b3653bd5e41e37a1">string_is_integer</a> (std::string_view s)</td></tr>
<tr class="memdesc:a4980b240c34b6656b3653bd5e41e37a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a string-like s is integer-like (including -)  <br /></td></tr>
<tr class="separator:a4980b240c34b6656b3653bd5e41e37a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512098e96b452117a140982098df2b4f" id="r_a512098e96b452117a140982098df2b4f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a512098e96b452117a140982098df2b4f">split</a> (const std::string &amp;s, char delim=' ')</td></tr>
<tr class="memdesc:a512098e96b452117a140982098df2b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string by delimeter into a vector.  <br /></td></tr>
<tr class="separator:a512098e96b452117a140982098df2b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2706f1118f1c85c034374d42933126ea" id="r_a2706f1118f1c85c034374d42933126ea"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a2706f1118f1c85c034374d42933126ea">concat</a> (const std::vector&lt; std::string &gt; &amp;v, const std::string &amp;delim=&quot;&quot;)</td></tr>
<tr class="memdesc:a2706f1118f1c85c034374d42933126ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes vector of strings, concats into single string, with optional delimeter.  <br /></td></tr>
<tr class="separator:a2706f1118f1c85c034374d42933126ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7db247b4ce6a20fd2141c0ad6510f8" id="r_ada7db247b4ce6a20fd2141c0ad6510f8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ada7db247b4ce6a20fd2141c0ad6510f8">wrap</a> (const std::string &amp;input, std::size_t at=80, const std::string &amp;prefix=&quot;&quot;)</td></tr>
<tr class="memdesc:ada7db247b4ce6a20fd2141c0ad6510f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the string, 'input', at line 'at'. Optionally appends a prefix 'prefix' to each line. Does not split words (if can be avoided)  <br /></td></tr>
<tr class="separator:ada7db247b4ce6a20fd2141c0ad6510f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd7b5f3792ab47d819e447bb3c1b1a2" id="r_a7fd7b5f3792ab47d819e447bb3c1b1a2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a7fd7b5f3792ab47d819e447bb3c1b1a2">int_to_roman</a> (int a)</td></tr>
<tr class="memdesc:a7fd7b5f3792ab47d819e447bb3c1b1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts integer, a, to Roman Numerals. Assumed that |a|&lt;=4000.  <br /></td></tr>
<tr class="separator:a7fd7b5f3792ab47d819e447bb3c1b1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed5643be032b796f63defc0db341f3f" id="r_a7ed5643be032b796f63defc0db341f3f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a7ed5643be032b796f63defc0db341f3f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a7ed5643be032b796f63defc0db341f3f">merge</a> (std::vector&lt; T &gt; first, const std::vector&lt; T &gt; &amp;second, const Args &amp;...rest)</td></tr>
<tr class="memdesc:a7ed5643be032b796f63defc0db341f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges a number of vectors: {a,b,c},{d,e},{f} -&gt; {a,b,c,d,e,f}.  <br /></td></tr>
<tr class="separator:a7ed5643be032b796f63defc0db341f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2feca8ceeedd078122dc9bac30a7d6" id="r_aca2feca8ceeedd078122dc9bac30a7d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca2feca8ceeedd078122dc9bac30a7d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aca2feca8ceeedd078122dc9bac30a7d6">compare</a> (const std::vector&lt; T &gt; &amp;first, const std::vector&lt; T &gt; &amp;second)</td></tr>
<tr class="memdesc:aca2feca8ceeedd078122dc9bac30a7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly compare two arithmetic vectors of the same type and length. Returns pair {delta, itr} where delta = |max|{first - second}, itr is iterator to position in first vector where the maximum delta occured. Note: Maximum is by magnitude, but delta is signed as (first-second)  <br /></td></tr>
<tr class="separator:aca2feca8ceeedd078122dc9bac30a7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c41c906c90e34a8f2770b69ab2b486c" id="r_a4c41c906c90e34a8f2770b69ab2b486c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename Func &gt; </td></tr>
<tr class="memitem:a4c41c906c90e34a8f2770b69ab2b486c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a4c41c906c90e34a8f2770b69ab2b486c">compare</a> (const std::vector&lt; T &gt; &amp;first, const std::vector&lt; U &gt; &amp;second, Func &amp;func)</td></tr>
<tr class="memdesc:a4c41c906c90e34a8f2770b69ab2b486c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two vectors of the same length, according to the rule given by func. Returns pair {delta, itr} where delta = max{|func(first,second)|}, itr is iterator to position in first vector where the maximum delta occured. Note: Maximum is by magnitude.  <br /></td></tr>
<tr class="separator:a4c41c906c90e34a8f2770b69ab2b486c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1250da0bd75d06567ef62d2b3fe349de" id="r_a1250da0bd75d06567ef62d2b3fe349de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1250da0bd75d06567ef62d2b3fe349de"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a1250da0bd75d06567ef62d2b3fe349de">compare_eps</a> (const std::vector&lt; T &gt; &amp;first, const std::vector&lt; T &gt; &amp;second)</td></tr>
<tr class="memdesc:a1250da0bd75d06567ef62d2b3fe349de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares values of two arithmetic vectors of the same type and length, relative to second value. Returns pair {eps, itr} where eps = |max|{(first - second)/second}, itr is iterator to position in first vector where the maximum eps occured. Note: Maximum is by magnitude, but eps is signed as (first-second)/second.  <br /></td></tr>
<tr class="separator:a1250da0bd75d06567ef62d2b3fe349de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ad20d5fb047e9cac680e9ce436fa4a" id="r_a08ad20d5fb047e9cac680e9ce436fa4a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a08ad20d5fb047e9cac680e9ce436fa4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a08ad20d5fb047e9cac680e9ce436fa4a">add</a> (std::vector&lt; T &gt; *first, const std::vector&lt; T &gt; &amp;second, const Args &amp;...rest)</td></tr>
<tr class="memdesc:a08ad20d5fb047e9cac680e9ce436fa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds any number of vectors, in place (modifies first vector). Must be of same type. May allocate; will resize first to be size of largest vector.  <br /></td></tr>
<tr class="separator:a08ad20d5fb047e9cac680e9ce436fa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347ad5fbbd12145050c65ae6f7f6e272" id="r_a347ad5fbbd12145050c65ae6f7f6e272"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a347ad5fbbd12145050c65ae6f7f6e272"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a347ad5fbbd12145050c65ae6f7f6e272">add</a> (std::vector&lt; T &gt; first, const std::vector&lt; T &gt; &amp;second, const Args &amp;...rest)</td></tr>
<tr class="memdesc:a347ad5fbbd12145050c65ae6f7f6e272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds any number of vectors. Must be of same type. Size of returned vector will be size of largest vector; may allocate more than once if vectors are not all of same size.  <br /></td></tr>
<tr class="separator:a347ad5fbbd12145050c65ae6f7f6e272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75f1779029d7480d8cf81499e1ad2a8" id="r_ac75f1779029d7480d8cf81499e1ad2a8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ac75f1779029d7480d8cf81499e1ad2a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ac75f1779029d7480d8cf81499e1ad2a8">multiply</a> (std::vector&lt; T &gt; *first, const std::vector&lt; T &gt; &amp;second, const Args &amp;...rest)</td></tr>
<tr class="memdesc:ac75f1779029d7480d8cf81499e1ad2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies any number of (arithmetic) vectors, in place (modifies first vector). Must be of same type. May allocate; will resize first to be size of largest vector.  <br /></td></tr>
<tr class="separator:ac75f1779029d7480d8cf81499e1ad2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf92025db181c7e03666680a2b3b651" id="r_a3bf92025db181c7e03666680a2b3b651"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a3bf92025db181c7e03666680a2b3b651"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a3bf92025db181c7e03666680a2b3b651">multiply</a> (std::vector&lt; T &gt; first, const std::vector&lt; T &gt; &amp;second, const Args &amp;...rest)</td></tr>
<tr class="memdesc:a3bf92025db181c7e03666680a2b3b651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies any number of vectors. Must be of same type. Size of returned vector will be size of largest vector; may allocate more than once if vectors are not all of same size.  <br /></td></tr>
<tr class="separator:a3bf92025db181c7e03666680a2b3b651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1400c774970ff089ae662d3013a0fa18" id="r_a1400c774970ff089ae662d3013a0fa18"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a1400c774970ff089ae662d3013a0fa18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a1400c774970ff089ae662d3013a0fa18">compose</a> (const F &amp;func, std::vector&lt; T &gt; *first, const std::vector&lt; T &gt; &amp;second, const Args &amp;...rest)</td></tr>
<tr class="memdesc:a1400c774970ff089ae662d3013a0fa18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes any number of vectors, in place (modifies first vector), using the provided function. Must be of same type. May allocate; will resize first to be size of largest vector. e.g., qip::compose(std::plus{}, &amp;vo, v2, v3); same as qip::add(&amp;vo, v2, v3)  <br /></td></tr>
<tr class="separator:a1400c774970ff089ae662d3013a0fa18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38b040174e185b3a4d0c16721ab64fb" id="r_ae38b040174e185b3a4d0c16721ab64fb"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ae38b040174e185b3a4d0c16721ab64fb"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ae38b040174e185b3a4d0c16721ab64fb">compose</a> (const F &amp;func, std::vector&lt; T &gt; first, const std::vector&lt; T &gt; &amp;second, const Args &amp;...rest)</td></tr>
<tr class="memdesc:ae38b040174e185b3a4d0c16721ab64fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes any number of vectors. Must be of same type. Size of returned vector will be size of largest vector; may allocate more than once if vectors are not all of same size.  <br /></td></tr>
<tr class="separator:ae38b040174e185b3a4d0c16721ab64fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1419dc459f6c79c3271ce4c7608292a6" id="r_a1419dc459f6c79c3271ce4c7608292a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1419dc459f6c79c3271ce4c7608292a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a1419dc459f6c79c3271ce4c7608292a6">scale</a> (std::vector&lt; T &gt; *vec, T x)</td></tr>
<tr class="memdesc:a1419dc459f6c79c3271ce4c7608292a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place scalar multiplication of std::vector - types must match.  <br /></td></tr>
<tr class="separator:a1419dc459f6c79c3271ce4c7608292a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ea690545e95c4cbb559c1d936a034a" id="r_ae8ea690545e95c4cbb559c1d936a034a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8ea690545e95c4cbb559c1d936a034a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ae8ea690545e95c4cbb559c1d936a034a">scale</a> (std::vector&lt; T &gt; vec, T x)</td></tr>
<tr class="memdesc:ae8ea690545e95c4cbb559c1d936a034a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication of std::vector - types must match.  <br /></td></tr>
<tr class="separator:ae8ea690545e95c4cbb559c1d936a034a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f43b1ed43949002db82bb97717c89af" id="r_a7f43b1ed43949002db82bb97717c89af"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, typename N  = std::size_t&gt; </td></tr>
<tr class="memitem:a7f43b1ed43949002db82bb97717c89af"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a7f43b1ed43949002db82bb97717c89af">uniform_range</a> (T first, T last, N number)</td></tr>
<tr class="memdesc:a7f43b1ed43949002db82bb97717c89af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a uniformly*(see below) distributed range of values between [first,last] with number steps. number must be at least 2. first+last are guarenteed to be the first and last points in the range. For integral T, range will not be perfectly uniform, due to [first, ..., last] guarentee and rounding; also in this case same value may appear more than once if too-many steps are requested.  <br /></td></tr>
<tr class="separator:a7f43b1ed43949002db82bb97717c89af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09522e3b06f11fdfb7319b5488e0191c" id="r_a09522e3b06f11fdfb7319b5488e0191c"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, typename N  = std::size_t&gt; </td></tr>
<tr class="memitem:a09522e3b06f11fdfb7319b5488e0191c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a09522e3b06f11fdfb7319b5488e0191c">logarithmic_range</a> (T first, T last, N number)</td></tr>
<tr class="memdesc:a09522e3b06f11fdfb7319b5488e0191c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a logarithmicly*(see below) distributed range of values between [first,last] with number steps. number must be at least 2. first+last are guarenteed to be the first and last points in the range. For integral T, range will not be perfectly logarithmic, due to [first, ..., last] guarentee and rounding; also in this case same value may appear more than once if too-many steps are requested.  <br /></td></tr>
<tr class="separator:a09522e3b06f11fdfb7319b5488e0191c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadf9f2174b75ec5ca85a442d5b64344" id="r_aeadf9f2174b75ec5ca85a442d5b64344"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, typename N  = std::size_t&gt; </td></tr>
<tr class="memitem:aeadf9f2174b75ec5ca85a442d5b64344"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aeadf9f2174b75ec5ca85a442d5b64344">loglinear_range</a> (T first, T last, T b, N number)</td></tr>
<tr class="memdesc:aeadf9f2174b75ec5ca85a442d5b64344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a Log-Linear distributed range of values between [first,last] with number steps. number must be at least 3. first+last are guarenteed to be the first and last points in the range. T must be floating point. Range is roughly logarithmic for values below 'b', and linear for values above b. Not tested for negative values.  <br /></td></tr>
<tr class="separator:aeadf9f2174b75ec5ca85a442d5b64344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14597b0bab192d9257ce42c1fc70e85" id="r_af14597b0bab192d9257ce42c1fc70e85"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:af14597b0bab192d9257ce42c1fc70e85"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#af14597b0bab192d9257ce42c1fc70e85">multiply_at</a> (std::size_t i, const T &amp;first, const Args &amp;...rest)</td></tr>
<tr class="memdesc:af14597b0bab192d9257ce42c1fc70e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">first[i]*...rest[i] &ndash; used to allow inner_product  <br /></td></tr>
<tr class="separator:af14597b0bab192d9257ce42c1fc70e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa139bdda88f1dd07dade6962ecbd94cd" id="r_aa139bdda88f1dd07dade6962ecbd94cd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aa139bdda88f1dd07dade6962ecbd94cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aa139bdda88f1dd07dade6962ecbd94cd">inner_product</a> (const T &amp;first, const Args &amp;...rest)</td></tr>
<tr class="memdesc:aa139bdda88f1dd07dade6962ecbd94cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic inner product (v1,v2,...vn) : sum_i v1[i]*v2[i]*...vn[i].  <br /></td></tr>
<tr class="separator:aa139bdda88f1dd07dade6962ecbd94cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6393c1e917792bd35b1f0df797d937" id="r_a1f6393c1e917792bd35b1f0df797d937"><td class="memTemplParams" colspan="2"><a id="a1f6393c1e917792bd35b1f0df797d937" name="a1f6393c1e917792bd35b1f0df797d937"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a1f6393c1e917792bd35b1f0df797d937"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inner_product_sub</b> (std::size_t p0, std::size_t pinf, const T &amp;first, const Args &amp;...rest)</td></tr>
<tr class="separator:a1f6393c1e917792bd35b1f0df797d937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625393770774da4553b27cbb967cf9c9" id="r_a625393770774da4553b27cbb967cf9c9"><td class="memTemplParams" colspan="2"><a id="a625393770774da4553b27cbb967cf9c9" name="a625393770774da4553b27cbb967cf9c9"></a>
template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a625393770774da4553b27cbb967cf9c9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_to</b> (const F &amp;func, T list)</td></tr>
<tr class="separator:a625393770774da4553b27cbb967cf9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e15dafae29a2429e1cf81fba46f07ce" id="r_a2e15dafae29a2429e1cf81fba46f07ce"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Func &gt; </td></tr>
<tr class="memitem:a2e15dafae29a2429e1cf81fba46f07ce"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a2e15dafae29a2429e1cf81fba46f07ce">select_if</a> (const std::vector&lt; T &gt; &amp;in, Func condition)</td></tr>
<tr class="memdesc:a2e15dafae29a2429e1cf81fba46f07ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a subset of a vector, whose element match condition. By copy. condition must have function signature: bool condition(T)  <br /></td></tr>
<tr class="separator:a2e15dafae29a2429e1cf81fba46f07ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cd248db2ab60ba720702329248f400" id="r_ab7cd248db2ab60ba720702329248f400"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Func &gt; </td></tr>
<tr class="memitem:ab7cd248db2ab60ba720702329248f400"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ab7cd248db2ab60ba720702329248f400">insert_into_if</a> (const std::vector&lt; T &gt; &amp;in, std::vector&lt; T &gt; *inout, Func condition)</td></tr>
<tr class="memdesc:ab7cd248db2ab60ba720702329248f400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from in into inout, if condition is met.  <br /></td></tr>
<tr class="separator:ab7cd248db2ab60ba720702329248f400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831b87ecaa1c2cceabaa3bfe89c9c8aa" id="r_a831b87ecaa1c2cceabaa3bfe89c9c8aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a831b87ecaa1c2cceabaa3bfe89c9c8aa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a831b87ecaa1c2cceabaa3bfe89c9c8aa">reverse</a> (std::vector&lt; T &gt; in)</td></tr>
<tr class="memdesc:a831b87ecaa1c2cceabaa3bfe89c9c8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses a list.  <br /></td></tr>
<tr class="separator:a831b87ecaa1c2cceabaa3bfe89c9c8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c5e3b3a8b13f23937e5d3719fa38d5" id="r_a61c5e3b3a8b13f23937e5d3719fa38d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61c5e3b3a8b13f23937e5d3719fa38d5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a61c5e3b3a8b13f23937e5d3719fa38d5">mean</a> (std::vector&lt; T &gt; vec)</td></tr>
<tr class="memdesc:a61c5e3b3a8b13f23937e5d3719fa38d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mean: \( \bar x = \sum_i x_i / N \).  <br /></td></tr>
<tr class="separator:a61c5e3b3a8b13f23937e5d3719fa38d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ebd17308b749a86f00fae2627d20c6" id="r_ad2ebd17308b749a86f00fae2627d20c6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2ebd17308b749a86f00fae2627d20c6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#ad2ebd17308b749a86f00fae2627d20c6">variance</a> (std::vector&lt; T &gt; vec, std::size_t dof=0)</td></tr>
<tr class="memdesc:ad2ebd17308b749a86f00fae2627d20c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variance using two-pass method: \( \sum_i (x_i-xbar)^2 / (N-dof) \). dof is degrees of freedom; for sample variance dof = 1.  <br /></td></tr>
<tr class="separator:ad2ebd17308b749a86f00fae2627d20c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2824625f3c7dc8c1daaf45bc92655f3" id="r_aa2824625f3c7dc8c1daaf45bc92655f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2824625f3c7dc8c1daaf45bc92655f3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#aa2824625f3c7dc8c1daaf45bc92655f3">sdev</a> (std::vector&lt; T &gt; vec, std::size_t dof=0)</td></tr>
<tr class="memdesc:aa2824625f3c7dc8c1daaf45bc92655f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard deviation: sqrt(variance)  <br /></td></tr>
<tr class="separator:aa2824625f3c7dc8c1daaf45bc92655f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb235d24ab2f094f6daa4ef1becd7c7" id="r_a1fb235d24ab2f094f6daa4ef1becd7c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1fb235d24ab2f094f6daa4ef1becd7c7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqip.html#a1fb235d24ab2f094f6daa4ef1becd7c7">sem</a> (std::vector&lt; T &gt; vec, std::size_t dof=0)</td></tr>
<tr class="memdesc:a1fb235d24ab2f094f6daa4ef1becd7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard deviation: sqrt(variance)  <br /></td></tr>
<tr class="separator:a1fb235d24ab2f094f6daa4ef1becd7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2628db4b1490c94df434d06b079d40" id="r_a1c2628db4b1490c94df434d06b079d40"><td class="memItemLeft" align="right" valign="top"><a id="a1c2628db4b1490c94df434d06b079d40" name="a1c2628db4b1490c94df434d06b079d40"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>progbar</b> (int i, int <a class="el" href="namespaceqip.html#a2fa8ce8b7b2ea7201cf954b9c52cc2dd">max</a>, int length=50)</td></tr>
<tr class="separator:a1c2628db4b1490c94df434d06b079d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f3de5012f99fe145d780e974ac609d" id="r_a32f3de5012f99fe145d780e974ac609d"><td class="memItemLeft" align="right" valign="top"><a id="a32f3de5012f99fe145d780e974ac609d" name="a32f3de5012f99fe145d780e974ac609d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>progbar50</b> (int i, int <a class="el" href="namespaceqip.html#a2fa8ce8b7b2ea7201cf954b9c52cc2dd">max</a>)</td></tr>
<tr class="separator:a32f3de5012f99fe145d780e974ac609d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aae0f3a7b4bdf301c1d6f8bf8799144a5" id="r_aae0f3a7b4bdf301c1d6f8bf8799144a5"><td class="memItemLeft" align="right" valign="top"><a id="aae0f3a7b4bdf301c1d6f8bf8799144a5" name="aae0f3a7b4bdf301c1d6f8bf8799144a5"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>use_omp</b> = false</td></tr>
<tr class="separator:aae0f3a7b4bdf301c1d6f8bf8799144a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>qip library: A collection of useful functions </p>
<p>Collection of handy tools. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aaaf20d224ad6ef434bb4422ee160ef55" name="aaaf20d224ad6ef434bb4422ee160ef55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf20d224ad6ef434bb4422ee160ef55">&#9670;&#160;</a></span>product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T qip::product </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variadic product - helper function. </p>

</div>
</div>
<a id="a3bffe52945e07e097fb95f9877e12a79" name="a3bffe52945e07e097fb95f9877e12a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bffe52945e07e097fb95f9877e12a79">&#9670;&#160;</a></span>NDrange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qip::NDrange </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variadic array of all possible indexes. </p>
<p>Allows ranged for loop like: for ([i,j,k,m,...,z] : array){ array.at(i,j,k,m,...,z); } Note: not memory efficient at all! Don't use for large arrays </p>

</div>
</div>
<a id="a2fa8ce8b7b2ea7201cf954b9c52cc2dd" name="a2fa8ce8b7b2ea7201cf954b9c52cc2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa8ce8b7b2ea7201cf954b9c52cc2dd">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T qip::max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns maximum of any number of parameters (variadic function) </p>

</div>
</div>
<a id="aa9e81dfdf0cd840d0ead840f72a066be" name="aa9e81dfdf0cd840d0ead840f72a066be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e81dfdf0cd840d0ead840f72a066be">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T qip::min </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns minimum of any number of parameters (variadic function) </p>

</div>
</div>
<a id="a80b99af2e2e2a1d9438a995c2555f51e" name="a80b99af2e2e2a1d9438a995c2555f51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b99af2e2e2a1d9438a995c2555f51e">&#9670;&#160;</a></span>max_abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T qip::max_abs </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns value with maximum absolute value of any number of parameters (variadic function) </p>

</div>
</div>
<a id="ac2670fff7c6536bb13a8d677336e72fb" name="ac2670fff7c6536bb13a8d677336e72fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2670fff7c6536bb13a8d677336e72fb">&#9670;&#160;</a></span>min_abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T qip::min_abs </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns value with minimum absolute value of any number of parameters (variadic function) </p>

</div>
</div>
<a id="a1fe1bfb56638d7c8dccdff2d6b8f07ad" name="a1fe1bfb56638d7c8dccdff2d6b8f07ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe1bfb56638d7c8dccdff2d6b8f07ad">&#9670;&#160;</a></span>max_difference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T qip::max_difference </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns max{args..} - min{args...}, for any number of args (variadic) </p>

</div>
</div>
<a id="ae93902898009ff74b7ff28f72ba7bcf2" name="ae93902898009ff74b7ff28f72ba7bcf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93902898009ff74b7ff28f72ba7bcf2">&#9670;&#160;</a></span>pow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto qip::pow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>x^n for integer n (n compile-time template parameter), x any arithmetic type (T). Returns double for inverse powers, T otherwise </p>

</div>
</div>
<a id="a9d5f2fdede884dd745ce55f2da0f5d7d" name="a9d5f2fdede884dd745ce55f2da0f5d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5f2fdede884dd745ce55f2da0f5d7d">&#9670;&#160;</a></span>pow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T qip::pow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>x^n for integer n (runtime n), x any floating point type (T). </p>

</div>
</div>
<a id="aa1353142288a3dea2be6eeedbe241e0b" name="aa1353142288a3dea2be6eeedbe241e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1353142288a3dea2be6eeedbe241e0b">&#9670;&#160;</a></span>factorial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T qip::factorial </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factorial x! - nb: does not check for overflow. Max x is 20 for uint64_t. Note: returns 1 for arguments &lt;0. </p>

</div>
</div>
<a id="a1569a13a7405afcf571cbac822eab9d2" name="a1569a13a7405afcf571cbac822eab9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1569a13a7405afcf571cbac822eab9d2">&#9670;&#160;</a></span>double_factorial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T qip::double_factorial </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double factorial x!! - nb: does not check for overflow. Max x is 20 for uint64_t. </p>

</div>
</div>
<a id="a762e6d5bf39ffca404e2d778fafbb0d9" name="a762e6d5bf39ffca404e2d778fafbb0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762e6d5bf39ffca404e2d778fafbb0d9">&#9670;&#160;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int qip::sign </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns sign of value. Note: sign(0)==0. </p>

</div>
</div>
<a id="af091ad44ba19b2538888cf9487af0e31" name="af091ad44ba19b2538888cf9487af0e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af091ad44ba19b2538888cf9487af0e31">&#9670;&#160;</a></span>clip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T qip::clip </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max_abs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clips value to between -max &lt;= value &lt;= max clip(x,max) : |x| &gt; max, ret max; if |x|&lt;-max, -max; else x. </p>

</div>
</div>
<a id="ab62de3c5b336d174e02feabf709867f3" name="ab62de3c5b336d174e02feabf709867f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62de3c5b336d174e02feabf709867f3">&#9670;&#160;</a></span>chop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T qip::chop </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min_abs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets values |v|&lt;min to zero; if |v|&gt;=min, returns v. </p>

</div>
</div>
<a id="a577a0e5927c5e966a43237a627fa3824" name="a577a0e5927c5e966a43237a627fa3824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577a0e5927c5e966a43237a627fa3824">&#9670;&#160;</a></span>derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Real, Real &gt; qip::derivative </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>delta_target</em> = <code>Real{1.0e-6}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>dx</em> = <code>Real{0.01}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>it_limit</em> = <code>250</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slow, but accurate, method of finding derivative of function (y) at a point (x). Returns derivative + error estimate. </p>
<p>delta_target is target for |dy/dx_n - dy/dx_{n+1}| &lt; delta_target (1.0e-6); dx is initial step-size used to find derivative of f (0.01); it_limit is maximum number of iterations. </p>

</div>
</div>
<a id="a741388b88ce35a381243800765e5dc7c" name="a741388b88ce35a381243800765e5dc7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741388b88ce35a381243800765e5dc7c">&#9670;&#160;</a></span>Newtons() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Real, Real &gt; qip::Newtons </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>delta_target</em> = <code>Real{1.0e-6}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>dx</em> = <code>Real{0.01}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>it_limit</em> = <code>250</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve f(x) = 0 for x using Newtons method. Returns root + error estimate/. </p>
<p>x is be initial guess for the root; delta_target is target for |x_n - x_{n+1}| &lt; delta_target (1.0e-6); dx is initial step-size used to find derivative of f (0.01); it_limit is maximum number of iterations. </p>

</div>
</div>
<a id="a60d843d875d5c96318cf4cb71057832d" name="a60d843d875d5c96318cf4cb71057832d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d843d875d5c96318cf4cb71057832d">&#9670;&#160;</a></span>Newtons() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Real, Real &gt; qip::Newtons </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; Real, Real &gt;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>delta_target</em> = <code>Real{1.0e-6}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>dx</em> = <code>Real{0.01}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>it_limit</em> = <code>250</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve f(x) = 0 for x using Newtons method. Returns root + error estimate. Enforced to be between bounds. </p>

</div>
</div>
<a id="a95825e5328321b8e0f83c230a42bd384" name="a95825e5328321b8e0f83c230a42bd384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95825e5328321b8e0f83c230a42bd384">&#9670;&#160;</a></span>fstring() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qip::fstring </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a formatted std::string, with formatting printf-like commands. Note: maximum string lenth is 256 characters. If longer string required, use provided overload. </p>

</div>
</div>
<a id="a97f77c0373bce44b37d7e26af0f03de4" name="a97f77c0373bce44b37d7e26af0f03de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f77c0373bce44b37d7e26af0f03de4">&#9670;&#160;</a></span>fstring() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qip::fstring </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload: size is maximum string length (buffer size). </p>

</div>
</div>
<a id="aae6b3539250c3e8aec56e34d8588fb15" name="aae6b3539250c3e8aec56e34d8588fb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6b3539250c3e8aec56e34d8588fb15">&#9670;&#160;</a></span>wildcard_compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qip::wildcard_compare </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings, s1 and s2. s2 may contain ONE wildcard ('*') which will match anything. </p>

</div>
</div>
<a id="aec0c485769c3134b6746de97235628d7" name="aec0c485769c3134b6746de97235628d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0c485769c3134b6746de97235628d7">&#9670;&#160;</a></span>tolower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char qip::tolower </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return static_cast&lt;char&gt;(std::tolower(static_cast&lt;unsigned char&gt;(ch))); </p>

</div>
</div>
<a id="abb7576d85706d41db6a1c8ca472866dc" name="abb7576d85706d41db6a1c8ca472866dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7576d85706d41db6a1c8ca472866dc">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qip::contains </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>the_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sub_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the_string (arg1) constaints sub_string (arg2) </p>

</div>
</div>
<a id="a52a6c501f456cc229942b577ba0347aa" name="a52a6c501f456cc229942b577ba0347aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a6c501f456cc229942b577ba0347aa">&#9670;&#160;</a></span>ci_contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qip::ci_contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>the_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sub_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the_string (arg1) constaints sub_string (arg2), case insensitive. </p>

</div>
</div>
<a id="a2b0e908b7ea1a3aae2063dff50e670de" name="a2b0e908b7ea1a3aae2063dff50e670de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0e908b7ea1a3aae2063dff50e670de">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qip::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>the_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_strings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the_string (arg1) constaints any of the sub_strings (arg2) </p>

</div>
</div>
<a id="a981f2e3696ed3fea34d7358cb3325679" name="a981f2e3696ed3fea34d7358cb3325679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981f2e3696ed3fea34d7358cb3325679">&#9670;&#160;</a></span>ci_contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qip::ci_contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>the_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_strings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the_string (arg1) constaints any of the sub_strings (arg2), case insensitive. </p>

</div>
</div>
<a id="a964aa73cc730e146911083bbf6828a41" name="a964aa73cc730e146911083bbf6828a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964aa73cc730e146911083bbf6828a41">&#9670;&#160;</a></span>ci_compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qip::ci_compare </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Case insensitive string compare. Essentially: LowerCase(s1)==LowerCase(s2) </p>

</div>
</div>
<a id="a7ea76ebd33dccecb8ded6e3b3ba447bc" name="a7ea76ebd33dccecb8ded6e3b3ba447bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea76ebd33dccecb8ded6e3b3ba447bc">&#9670;&#160;</a></span>ci_wc_compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qip::ci_wc_compare </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings, s1 and s2. s2 may contain ONE wildcard ('*') which will match anything. Case Insensitive version. </p>

</div>
</div>
<a id="a2a229fdb6b5d87ccda7d872052a8072b" name="a2a229fdb6b5d87ccda7d872052a8072b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a229fdb6b5d87ccda7d872052a8072b">&#9670;&#160;</a></span>Levenstein()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto qip::Levenstein </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple non-optimised implementation of the Levenshtein distance. </p>

</div>
</div>
<a id="a7591544d632a747d922c0968a18a1482" name="a7591544d632a747d922c0968a18a1482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7591544d632a747d922c0968a18a1482">&#9670;&#160;</a></span>ci_Levenstein()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto qip::ci_Levenstein </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple non-optimised implementation of the Levenshtein distance (case insensitive) </p>

</div>
</div>
<a id="a0c662c083f1a052ac4ef6d5e3cd4a90d" name="a0c662c083f1a052ac4ef6d5e3cd4a90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c662c083f1a052ac4ef6d5e3cd4a90d">&#9670;&#160;</a></span>closest_match()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto qip::closest_match </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>test_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the closest match in list to test_string (return iterator) </p>

</div>
</div>
<a id="acf877c3d7f4589f0c680e22640e821b5" name="acf877c3d7f4589f0c680e22640e821b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf877c3d7f4589f0c680e22640e821b5">&#9670;&#160;</a></span>ci_closest_match()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto qip::ci_closest_match </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>test_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the closest match (case insensitive) in list to test_string (return iterator) </p>

</div>
</div>
<a id="a4980b240c34b6656b3653bd5e41e37a1" name="a4980b240c34b6656b3653bd5e41e37a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4980b240c34b6656b3653bd5e41e37a1">&#9670;&#160;</a></span>string_is_integer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qip::string_is_integer </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a string-like s is integer-like (including -) </p>
<p>e.g., The input strings "16" and "-12" would both return 'true', while "12x" or "12.5" would not. Does this by checking if all characters are integer digits exept first character, which is allowed to be an integer, or '+' or -'- </p>

</div>
</div>
<a id="a512098e96b452117a140982098df2b4f" name="a512098e96b452117a140982098df2b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512098e96b452117a140982098df2b4f">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; qip::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a string by delimeter into a vector. </p>

</div>
</div>
<a id="a2706f1118f1c85c034374d42933126ea" name="a2706f1118f1c85c034374d42933126ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2706f1118f1c85c034374d42933126ea">&#9670;&#160;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qip::concat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes vector of strings, concats into single string, with optional delimeter. </p>

</div>
</div>
<a id="ada7db247b4ce6a20fd2141c0ad6510f8" name="ada7db247b4ce6a20fd2141c0ad6510f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7db247b4ce6a20fd2141c0ad6510f8">&#9670;&#160;</a></span>wrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qip::wrap </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>at</em> = <code>80</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the string, 'input', at line 'at'. Optionally appends a prefix 'prefix' to each line. Does not split words (if can be avoided) </p>

</div>
</div>
<a id="a7fd7b5f3792ab47d819e447bb3c1b1a2" name="a7fd7b5f3792ab47d819e447bb3c1b1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd7b5f3792ab47d819e447bb3c1b1a2">&#9670;&#160;</a></span>int_to_roman()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qip::int_to_roman </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts integer, a, to Roman Numerals. Assumed that |a|&lt;=4000. </p>

</div>
</div>
<a id="a7ed5643be032b796f63defc0db341f3f" name="a7ed5643be032b796f63defc0db341f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed5643be032b796f63defc0db341f3f">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; qip::merge </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges a number of vectors: {a,b,c},{d,e},{f} -&gt; {a,b,c,d,e,f}. </p>

</div>
</div>
<a id="aca2feca8ceeedd078122dc9bac30a7d6" name="aca2feca8ceeedd078122dc9bac30a7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2feca8ceeedd078122dc9bac30a7d6">&#9670;&#160;</a></span>compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qip::compare </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directly compare two arithmetic vectors of the same type and length. Returns pair {delta, itr} where delta = |max|{first - second}, itr is iterator to position in first vector where the maximum delta occured. Note: Maximum is by magnitude, but delta is signed as (first-second) </p>

</div>
</div>
<a id="a4c41c906c90e34a8f2770b69ab2b486c" name="a4c41c906c90e34a8f2770b69ab2b486c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c41c906c90e34a8f2770b69ab2b486c">&#9670;&#160;</a></span>compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qip::compare </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two vectors of the same length, according to the rule given by func. Returns pair {delta, itr} where delta = max{|func(first,second)|}, itr is iterator to position in first vector where the maximum delta occured. Note: Maximum is by magnitude. </p>

</div>
</div>
<a id="a1250da0bd75d06567ef62d2b3fe349de" name="a1250da0bd75d06567ef62d2b3fe349de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1250da0bd75d06567ef62d2b3fe349de">&#9670;&#160;</a></span>compare_eps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qip::compare_eps </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares values of two arithmetic vectors of the same type and length, relative to second value. Returns pair {eps, itr} where eps = |max|{(first - second)/second}, itr is iterator to position in first vector where the maximum eps occured. Note: Maximum is by magnitude, but eps is signed as (first-second)/second. </p>

</div>
</div>
<a id="a08ad20d5fb047e9cac680e9ce436fa4a" name="a08ad20d5fb047e9cac680e9ce436fa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ad20d5fb047e9cac680e9ce436fa4a">&#9670;&#160;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qip::add </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds any number of vectors, in place (modifies first vector). Must be of same type. May allocate; will resize first to be size of largest vector. </p>

</div>
</div>
<a id="a347ad5fbbd12145050c65ae6f7f6e272" name="a347ad5fbbd12145050c65ae6f7f6e272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347ad5fbbd12145050c65ae6f7f6e272">&#9670;&#160;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; qip::add </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds any number of vectors. Must be of same type. Size of returned vector will be size of largest vector; may allocate more than once if vectors are not all of same size. </p>

</div>
</div>
<a id="ac75f1779029d7480d8cf81499e1ad2a8" name="ac75f1779029d7480d8cf81499e1ad2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75f1779029d7480d8cf81499e1ad2a8">&#9670;&#160;</a></span>multiply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qip::multiply </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies any number of (arithmetic) vectors, in place (modifies first vector). Must be of same type. May allocate; will resize first to be size of largest vector. </p>

</div>
</div>
<a id="a3bf92025db181c7e03666680a2b3b651" name="a3bf92025db181c7e03666680a2b3b651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf92025db181c7e03666680a2b3b651">&#9670;&#160;</a></span>multiply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; qip::multiply </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies any number of vectors. Must be of same type. Size of returned vector will be size of largest vector; may allocate more than once if vectors are not all of same size. </p>

</div>
</div>
<a id="a1400c774970ff089ae662d3013a0fa18" name="a1400c774970ff089ae662d3013a0fa18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1400c774970ff089ae662d3013a0fa18">&#9670;&#160;</a></span>compose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qip::compose </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes any number of vectors, in place (modifies first vector), using the provided function. Must be of same type. May allocate; will resize first to be size of largest vector. e.g., qip::compose(std::plus{}, &amp;vo, v2, v3); same as qip::add(&amp;vo, v2, v3) </p>

</div>
</div>
<a id="ae38b040174e185b3a4d0c16721ab64fb" name="ae38b040174e185b3a4d0c16721ab64fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38b040174e185b3a4d0c16721ab64fb">&#9670;&#160;</a></span>compose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; qip::compose </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes any number of vectors. Must be of same type. Size of returned vector will be size of largest vector; may allocate more than once if vectors are not all of same size. </p>

</div>
</div>
<a id="a1419dc459f6c79c3271ce4c7608292a6" name="a1419dc459f6c79c3271ce4c7608292a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1419dc459f6c79c3271ce4c7608292a6">&#9670;&#160;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qip::scale </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In-place scalar multiplication of std::vector - types must match. </p>

</div>
</div>
<a id="ae8ea690545e95c4cbb559c1d936a034a" name="ae8ea690545e95c4cbb559c1d936a034a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ea690545e95c4cbb559c1d936a034a">&#9670;&#160;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; qip::scale </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scalar multiplication of std::vector - types must match. </p>

</div>
</div>
<a id="a7f43b1ed43949002db82bb97717c89af" name="a7f43b1ed43949002db82bb97717c89af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f43b1ed43949002db82bb97717c89af">&#9670;&#160;</a></span>uniform_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = double, typename N  = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; qip::uniform_range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces a uniformly*(see below) distributed range of values between [first,last] with number steps. number must be at least 2. first+last are guarenteed to be the first and last points in the range. For integral T, range will not be perfectly uniform, due to [first, ..., last] guarentee and rounding; also in this case same value may appear more than once if too-many steps are requested. </p>

</div>
</div>
<a id="a09522e3b06f11fdfb7319b5488e0191c" name="a09522e3b06f11fdfb7319b5488e0191c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09522e3b06f11fdfb7319b5488e0191c">&#9670;&#160;</a></span>logarithmic_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = double, typename N  = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; qip::logarithmic_range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces a logarithmicly*(see below) distributed range of values between [first,last] with number steps. number must be at least 2. first+last are guarenteed to be the first and last points in the range. For integral T, range will not be perfectly logarithmic, due to [first, ..., last] guarentee and rounding; also in this case same value may appear more than once if too-many steps are requested. </p>

</div>
</div>
<a id="aeadf9f2174b75ec5ca85a442d5b64344" name="aeadf9f2174b75ec5ca85a442d5b64344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadf9f2174b75ec5ca85a442d5b64344">&#9670;&#160;</a></span>loglinear_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = double, typename N  = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; qip::loglinear_range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces a Log-Linear distributed range of values between [first,last] with number steps. number must be at least 3. first+last are guarenteed to be the first and last points in the range. T must be floating point. Range is roughly logarithmic for values below 'b', and linear for values above b. Not tested for negative values. </p>

</div>
</div>
<a id="af14597b0bab192d9257ce42c1fc70e85" name="af14597b0bab192d9257ce42c1fc70e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14597b0bab192d9257ce42c1fc70e85">&#9670;&#160;</a></span>multiply_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto qip::multiply_at </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>first[i]*...rest[i] &ndash; used to allow inner_product </p>

</div>
</div>
<a id="aa139bdda88f1dd07dade6962ecbd94cd" name="aa139bdda88f1dd07dade6962ecbd94cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa139bdda88f1dd07dade6962ecbd94cd">&#9670;&#160;</a></span>inner_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto qip::inner_product </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variadic inner product (v1,v2,...vn) : sum_i v1[i]*v2[i]*...vn[i]. </p>

</div>
</div>
<a id="a2e15dafae29a2429e1cf81fba46f07ce" name="a2e15dafae29a2429e1cf81fba46f07ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e15dafae29a2429e1cf81fba46f07ce">&#9670;&#160;</a></span>select_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; qip::select_if </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a subset of a vector, whose element match condition. By copy. condition must have function signature: bool condition(T) </p>

</div>
</div>
<a id="ab7cd248db2ab60ba720702329248f400" name="ab7cd248db2ab60ba720702329248f400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cd248db2ab60ba720702329248f400">&#9670;&#160;</a></span>insert_into_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qip::insert_into_if </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>inout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts elements from in into inout, if condition is met. </p>

</div>
</div>
<a id="a831b87ecaa1c2cceabaa3bfe89c9c8aa" name="a831b87ecaa1c2cceabaa3bfe89c9c8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831b87ecaa1c2cceabaa3bfe89c9c8aa">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; qip::reverse </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses a list. </p>

</div>
</div>
<a id="a61c5e3b3a8b13f23937e5d3719fa38d5" name="a61c5e3b3a8b13f23937e5d3719fa38d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c5e3b3a8b13f23937e5d3719fa38d5">&#9670;&#160;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T qip::mean </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mean: \( \bar x = \sum_i x_i / N \). </p>

</div>
</div>
<a id="ad2ebd17308b749a86f00fae2627d20c6" name="ad2ebd17308b749a86f00fae2627d20c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ebd17308b749a86f00fae2627d20c6">&#9670;&#160;</a></span>variance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T qip::variance </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dof</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variance using two-pass method: \( \sum_i (x_i-xbar)^2 / (N-dof) \). dof is degrees of freedom; for sample variance dof = 1. </p>

</div>
</div>
<a id="aa2824625f3c7dc8c1daaf45bc92655f3" name="aa2824625f3c7dc8c1daaf45bc92655f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2824625f3c7dc8c1daaf45bc92655f3">&#9670;&#160;</a></span>sdev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T qip::sdev </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dof</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard deviation: sqrt(variance) </p>

</div>
</div>
<a id="a1fb235d24ab2f094f6daa4ef1becd7c7" name="a1fb235d24ab2f094f6daa4ef1becd7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb235d24ab2f094f6daa4ef1becd7c7">&#9670;&#160;</a></span>sem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T qip::sem </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dof</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard deviation: sqrt(variance) </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceqip.html">qip</a></li>
    <li class="footer">Generated on Mon Mar 2 2026 04:48:12 for ampsci by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
