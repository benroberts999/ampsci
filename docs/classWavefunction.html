<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ampsci: Wavefunction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ampsci
   </div>
   <div id="projectbrief">c++ program for high-precision atomic structure calculations of single-valence systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classWavefunction-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Wavefunction</div></div>
</div><!--header-->
<div class="contents">

<p>Stores Wavefunction (set of valence orbitals, grid, HF etc.)  
 <a href="classWavefunction.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Wavefunction_8hpp_source.html">Wavefunction.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3473b40278e9fb30a09de1341bda6463" id="r_a3473b40278e9fb30a09de1341bda6463"><td class="memItemLeft" align="right" valign="top"><a id="a3473b40278e9fb30a09de1341bda6463" name="a3473b40278e9fb30a09de1341bda6463"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Wavefunction</b> (std::shared_ptr&lt; const <a class="el" href="classGrid.html">Grid</a> &gt; <a class="el" href="classWavefunction.html#a1a4247896d7b0a641c5231b10e845c21">grid</a>, const <a class="el" href="classNuclear_1_1Nucleus.html">Nuclear::Nucleus</a> &amp;<a class="el" href="classWavefunction.html#ae1926e6aaae366089ef238acea179740">nucleus</a>, double var_alpha=1.0, const std::string &amp;run_label=&quot;&quot;)</td></tr>
<tr class="memdesc:a3473b40278e9fb30a09de1341bda6463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with a Grid [shared resource], a nucleus (isotope data etc.), and (optional) fractional variation in alpha [alpha = var_alpha * alpha_0, alpha_0=~1/137]. <br /></td></tr>
<tr class="separator:a3473b40278e9fb30a09de1341bda6463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2b71a07e218611842fd8cb6c9f0cc0" id="r_abf2b71a07e218611842fd8cb6c9f0cc0"><td class="memItemLeft" align="right" valign="top"><a id="abf2b71a07e218611842fd8cb6c9f0cc0" name="abf2b71a07e218611842fd8cb6c9f0cc0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Wavefunction</b> (const <a class="el" href="structGridParameters.html">GridParameters</a> &amp;gridparams, const <a class="el" href="classNuclear_1_1Nucleus.html">Nuclear::Nucleus</a> &amp;<a class="el" href="classWavefunction.html#ae1926e6aaae366089ef238acea179740">nucleus</a>, double var_alpha=1.0, const std::string &amp;run_label=&quot;&quot;)</td></tr>
<tr class="memdesc:abf2b71a07e218611842fd8cb6c9f0cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but Grid is constructed here using given parameters. <br /></td></tr>
<tr class="separator:abf2b71a07e218611842fd8cb6c9f0cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4247896d7b0a641c5231b10e845c21" id="r_a1a4247896d7b0a641c5231b10e845c21"><td class="memItemLeft" align="right" valign="top"><a id="a1a4247896d7b0a641c5231b10e845c21" name="a1a4247896d7b0a641c5231b10e845c21"></a>
const <a class="el" href="classGrid.html">Grid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>grid</b> () const</td></tr>
<tr class="memdesc:a1a4247896d7b0a641c5231b10e845c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the radial grid. <br /></td></tr>
<tr class="separator:a1a4247896d7b0a641c5231b10e845c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19e0f728379513d6be58728d88f9869" id="r_aa19e0f728379513d6be58728d88f9869"><td class="memItemLeft" align="right" valign="top"><a id="aa19e0f728379513d6be58728d88f9869" name="aa19e0f728379513d6be58728d88f9869"></a>
std::shared_ptr&lt; const <a class="el" href="classGrid.html">Grid</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>grid_sptr</b> () const</td></tr>
<tr class="memdesc:aa19e0f728379513d6be58728d88f9869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy of shared_ptr to grid [shared resource] - used when we want to construct a new object that shares this grid. <br /></td></tr>
<tr class="separator:aa19e0f728379513d6be58728d88f9869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ce9d37c87076eb78e046e8157ac4b1" id="r_ab9ce9d37c87076eb78e046e8157ac4b1"><td class="memItemLeft" align="right" valign="top"><a id="ab9ce9d37c87076eb78e046e8157ac4b1" name="ab9ce9d37c87076eb78e046e8157ac4b1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>alpha</b> () const</td></tr>
<tr class="memdesc:ab9ce9d37c87076eb78e046e8157ac4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local value of fine-structure constant. <br /></td></tr>
<tr class="separator:ab9ce9d37c87076eb78e046e8157ac4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86101751063da7534e3a546f8d0a7b7" id="r_af86101751063da7534e3a546f8d0a7b7"><td class="memItemLeft" align="right" valign="top"><a id="af86101751063da7534e3a546f8d0a7b7" name="af86101751063da7534e3a546f8d0a7b7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>dalpha2</b> () const</td></tr>
<tr class="memdesc:af86101751063da7534e3a546f8d0a7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variation in alpha^2 : x = (alpha/alpha_0)^2 - 1. <br /></td></tr>
<tr class="separator:af86101751063da7534e3a546f8d0a7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1926e6aaae366089ef238acea179740" id="r_ae1926e6aaae366089ef238acea179740"><td class="memItemLeft" align="right" valign="top"><a id="ae1926e6aaae366089ef238acea179740" name="ae1926e6aaae366089ef238acea179740"></a>
const <a class="el" href="classNuclear_1_1Nucleus.html">Nuclear::Nucleus</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nucleus</b> () const</td></tr>
<tr class="memdesc:ae1926e6aaae366089ef238acea179740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Nuclear::nucleus object (contains nuc. parameters) <br /></td></tr>
<tr class="separator:ae1926e6aaae366089ef238acea179740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323a18d94cb2242a666a584be6ca08bc" id="r_a323a18d94cb2242a666a584be6ca08bc"><td class="memItemLeft" align="right" valign="top"><a id="a323a18d94cb2242a666a584be6ca08bc" name="a323a18d94cb2242a666a584be6ca08bc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Znuc</b> () const</td></tr>
<tr class="memdesc:a323a18d94cb2242a666a584be6ca08bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nuclear charge, Z. <br /></td></tr>
<tr class="separator:a323a18d94cb2242a666a584be6ca08bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a36b73812ebae2e76f55d475149fa9e" id="r_a6a36b73812ebae2e76f55d475149fa9e"><td class="memItemLeft" align="right" valign="top"><a id="a6a36b73812ebae2e76f55d475149fa9e" name="a6a36b73812ebae2e76f55d475149fa9e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Anuc</b> () const</td></tr>
<tr class="memdesc:a6a36b73812ebae2e76f55d475149fa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nuclear mass number, A. <br /></td></tr>
<tr class="separator:a6a36b73812ebae2e76f55d475149fa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736ad360b2a3ea96a65397a08aeffe85" id="r_a736ad360b2a3ea96a65397a08aeffe85"><td class="memItemLeft" align="right" valign="top"><a id="a736ad360b2a3ea96a65397a08aeffe85" name="a736ad360b2a3ea96a65397a08aeffe85"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>get_rrms</b> () const</td></tr>
<tr class="memdesc:a736ad360b2a3ea96a65397a08aeffe85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nuclear rms charge radii, in fm (femptometres) <br /></td></tr>
<tr class="separator:a736ad360b2a3ea96a65397a08aeffe85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b90973fd60052027eb4c9cdf338188" id="r_a17b90973fd60052027eb4c9cdf338188"><td class="memItemLeft" align="right" valign="top"><a id="a17b90973fd60052027eb4c9cdf338188" name="a17b90973fd60052027eb4c9cdf338188"></a>
const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>core</b> () const</td></tr>
<tr class="memdesc:a17b90973fd60052027eb4c9cdf338188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core orbitals (frozen HF core) <br /></td></tr>
<tr class="separator:a17b90973fd60052027eb4c9cdf338188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8f9e9452168727711b70c4b567c02e" id="r_a9e8f9e9452168727711b70c4b567c02e"><td class="memItemLeft" align="right" valign="top"><a id="a9e8f9e9452168727711b70c4b567c02e" name="a9e8f9e9452168727711b70c4b567c02e"></a>
const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>valence</b> () const</td></tr>
<tr class="memdesc:a9e8f9e9452168727711b70c4b567c02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valence orbitals (HF or Brueckner orbitals) <br /></td></tr>
<tr class="separator:a9e8f9e9452168727711b70c4b567c02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7165c3d78aadb2bfd4d5d54af00b9d" id="r_a9e7165c3d78aadb2bfd4d5d54af00b9d"><td class="memItemLeft" align="right" valign="top"><a id="a9e7165c3d78aadb2bfd4d5d54af00b9d" name="a9e7165c3d78aadb2bfd4d5d54af00b9d"></a>
std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>valence</b> ()</td></tr>
<tr class="separator:a9e7165c3d78aadb2bfd4d5d54af00b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f374ccbe05f929c4b50ff881243a7b" id="r_af9f374ccbe05f929c4b50ff881243a7b"><td class="memItemLeft" align="right" valign="top"><a id="af9f374ccbe05f929c4b50ff881243a7b" name="af9f374ccbe05f929c4b50ff881243a7b"></a>
const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>hf_valence</b> () const</td></tr>
<tr class="separator:af9f374ccbe05f929c4b50ff881243a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae278b50bf2fbf460c01467b2b217d946" id="r_ae278b50bf2fbf460c01467b2b217d946"><td class="memItemLeft" align="right" valign="top"><a id="ae278b50bf2fbf460c01467b2b217d946" name="ae278b50bf2fbf460c01467b2b217d946"></a>
const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>basis</b> () const</td></tr>
<tr class="memdesc:ae278b50bf2fbf460c01467b2b217d946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basis, eigenstates of HF potential. Used for MBPT. Includes Breit and QED (if they are included), but not correlations. <br /></td></tr>
<tr class="separator:ae278b50bf2fbf460c01467b2b217d946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5f0755b3953efda64d3a0f8f1e5111" id="r_a2d5f0755b3953efda64d3a0f8f1e5111"><td class="memItemLeft" align="right" valign="top"><a id="a2d5f0755b3953efda64d3a0f8f1e5111" name="a2d5f0755b3953efda64d3a0f8f1e5111"></a>
std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>basis</b> ()</td></tr>
<tr class="separator:a2d5f0755b3953efda64d3a0f8f1e5111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b422473f0bbf7bc52c3032ca94e26f7" id="r_a7b422473f0bbf7bc52c3032ca94e26f7"><td class="memItemLeft" align="right" valign="top"><a id="a7b422473f0bbf7bc52c3032ca94e26f7" name="a7b422473f0bbf7bc52c3032ca94e26f7"></a>
const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>spectrum</b> () const</td></tr>
<tr class="memdesc:a7b422473f0bbf7bc52c3032ca94e26f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sprectrum: like basis, but includes correlations. <br /></td></tr>
<tr class="separator:a7b422473f0bbf7bc52c3032ca94e26f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfa3331062652d5d489d5fca3690328" id="r_adbfa3331062652d5d489d5fca3690328"><td class="memItemLeft" align="right" valign="top"><a id="adbfa3331062652d5d489d5fca3690328" name="adbfa3331062652d5d489d5fca3690328"></a>
std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>spectrum</b> ()</td></tr>
<tr class="separator:adbfa3331062652d5d489d5fca3690328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999a03b9681a0823f4c586d779337c3a" id="r_a999a03b9681a0823f4c586d779337c3a"><td class="memItemLeft" align="right" valign="top"><a id="a999a03b9681a0823f4c586d779337c3a" name="a999a03b9681a0823f4c586d779337c3a"></a>
const std::vector&lt; <a class="el" href="classCI_1_1PsiJPi.html">CI::PsiJPi</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>CIwfs</b> () const</td></tr>
<tr class="separator:a999a03b9681a0823f4c586d779337c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4136b5d78cd407596f127c9c2e4f7bb0" id="r_a4136b5d78cd407596f127c9c2e4f7bb0"><td class="memItemLeft" align="right" valign="top"><a id="a4136b5d78cd407596f127c9c2e4f7bb0" name="a4136b5d78cd407596f127c9c2e4f7bb0"></a>
const <a class="el" href="classCI_1_1PsiJPi.html">CI::PsiJPi</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>CIwf</b> (int J, int parity) const</td></tr>
<tr class="separator:a4136b5d78cd407596f127c9c2e4f7bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c61333df5f06ae3eeffec2059734df" id="r_ad2c61333df5f06ae3eeffec2059734df"><td class="memItemLeft" align="right" valign="top"><a id="ad2c61333df5f06ae3eeffec2059734df" name="ad2c61333df5f06ae3eeffec2059734df"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>vnuc</b> () const</td></tr>
<tr class="memdesc:ad2c61333df5f06ae3eeffec2059734df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nuclear potential. Only provide const version, since HF and WF version of vnuc must be kept in sync. <br /></td></tr>
<tr class="separator:ad2c61333df5f06ae3eeffec2059734df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc22315745a7133a10b4883ed0433095" id="r_abc22315745a7133a10b4883ed0433095"><td class="memItemLeft" align="right" valign="top"><a id="abc22315745a7133a10b4883ed0433095" name="abc22315745a7133a10b4883ed0433095"></a>
const <a class="el" href="classHF_1_1HartreeFock.html">HF::HartreeFock</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>vHF</b> () const</td></tr>
<tr class="memdesc:abc22315745a7133a10b4883ed0433095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ptr to Hartree Fock (class) <br /></td></tr>
<tr class="separator:abc22315745a7133a10b4883ed0433095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b3c2edae4ebf2f2aef796ee6e11e12" id="r_a65b3c2edae4ebf2f2aef796ee6e11e12"><td class="memItemLeft" align="right" valign="top"><a id="a65b3c2edae4ebf2f2aef796ee6e11e12" name="a65b3c2edae4ebf2f2aef796ee6e11e12"></a>
<a class="el" href="classHF_1_1HartreeFock.html">HF::HartreeFock</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>vHF</b> ()</td></tr>
<tr class="separator:a65b3c2edae4ebf2f2aef796ee6e11e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509f57a02029972de24e25d0b7af658b" id="r_a509f57a02029972de24e25d0b7af658b"><td class="memItemLeft" align="right" valign="top"><a id="a509f57a02029972de24e25d0b7af658b" name="a509f57a02029972de24e25d0b7af658b"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vlocal</b> (int l=0) const</td></tr>
<tr class="memdesc:a509f57a02029972de24e25d0b7af658b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local part of potential, e.g., Vl = Vnuc + Vdir + Vrad_el(l) - can be l-dependent. Returns a copy. <br /></td></tr>
<tr class="separator:a509f57a02029972de24e25d0b7af658b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5192e8da13785d81238e388f3f93483b" id="r_a5192e8da13785d81238e388f3f93483b"><td class="memItemLeft" align="right" valign="top"><a id="a5192e8da13785d81238e388f3f93483b" name="a5192e8da13785d81238e388f3f93483b"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Hmag</b> (int l=0) const</td></tr>
<tr class="memdesc:a5192e8da13785d81238e388f3f93483b"><td class="mdescLeft">&#160;</td><td class="mdescRight">QED Magnetic form factor. May return empty vector. Not typically l-dependent, but may be in future. Returns a copy. <br /></td></tr>
<tr class="separator:a5192e8da13785d81238e388f3f93483b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27b17d8bec09ca0db8b2b4f1abc900d" id="r_ae27b17d8bec09ca0db8b2b4f1abc900d"><td class="memItemLeft" align="right" valign="top"><a id="ae27b17d8bec09ca0db8b2b4f1abc900d" name="ae27b17d8bec09ca0db8b2b4f1abc900d"></a>
const <a class="el" href="classQED_1_1RadPot.html">QED::RadPot</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>vrad</b> () const</td></tr>
<tr class="memdesc:ae27b17d8bec09ca0db8b2b4f1abc900d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to QED radiative potnential. May be nullptr. <br /></td></tr>
<tr class="separator:ae27b17d8bec09ca0db8b2b4f1abc900d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11907fdad6876abf41f61df163ffbc20" id="r_a11907fdad6876abf41f61df163ffbc20"><td class="memItemLeft" align="right" valign="top"><a id="a11907fdad6876abf41f61df163ffbc20" name="a11907fdad6876abf41f61df163ffbc20"></a>
<a class="el" href="classQED_1_1RadPot.html">QED::RadPot</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>vrad</b> ()</td></tr>
<tr class="separator:a11907fdad6876abf41f61df163ffbc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d145ed8d246f74130b22c3db9bd1eba" id="r_a7d145ed8d246f74130b22c3db9bd1eba"><td class="memItemLeft" align="right" valign="top"><a id="a7d145ed8d246f74130b22c3db9bd1eba" name="a7d145ed8d246f74130b22c3db9bd1eba"></a>
const MBPT::CorrelationPotential *&#160;</td><td class="memItemRight" valign="bottom"><b>Sigma</b> () const</td></tr>
<tr class="memdesc:a7d145ed8d246f74130b22c3db9bd1eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ptr to (const) Correlation Potential, Sigma. <br /></td></tr>
<tr class="separator:a7d145ed8d246f74130b22c3db9bd1eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f78c80b9218bab2125a90c254170bf" id="r_ab5f78c80b9218bab2125a90c254170bf"><td class="memItemLeft" align="right" valign="top"><a id="ab5f78c80b9218bab2125a90c254170bf" name="ab5f78c80b9218bab2125a90c254170bf"></a>
MBPT::CorrelationPotential *&#160;</td><td class="memItemRight" valign="bottom"><b>Sigma</b> ()</td></tr>
<tr class="separator:ab5f78c80b9218bab2125a90c254170bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcbf541d7102af9c59139aa8ba5288c" id="r_addcbf541d7102af9c59139aa8ba5288c"><td class="memItemLeft" align="right" valign="top"><a id="addcbf541d7102af9c59139aa8ba5288c" name="addcbf541d7102af9c59139aa8ba5288c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Ncore</b> () const</td></tr>
<tr class="memdesc:addcbf541d7102af9c59139aa8ba5288c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of electrons in the core. <br /></td></tr>
<tr class="separator:addcbf541d7102af9c59139aa8ba5288c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebe5ad5f71d03f2b34c2bad30c48b2e" id="r_a2ebe5ad5f71d03f2b34c2bad30c48b2e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a2ebe5ad5f71d03f2b34c2bad30c48b2e">getState</a> (int n, int k) const</td></tr>
<tr class="memdesc:a2ebe5ad5f71d03f2b34c2bad30c48b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds requested state; returns nullptr if not found.  <br /></td></tr>
<tr class="separator:a2ebe5ad5f71d03f2b34c2bad30c48b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb60417a573a87090c4207db31207c0" id="r_afcb60417a573a87090c4207db31207c0"><td class="memItemLeft" align="right" valign="top"><a id="afcb60417a573a87090c4207db31207c0" name="afcb60417a573a87090c4207db31207c0"></a>
const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getState</b> (std::string_view state) const</td></tr>
<tr class="memdesc:afcb60417a573a87090c4207db31207c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but takes 'short symbol' (e.g., 6s+, 6p-) <br /></td></tr>
<tr class="separator:afcb60417a573a87090c4207db31207c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae764a7998c1d99c3d090664901f350f0" id="r_ae764a7998c1d99c3d090664901f350f0"><td class="memItemLeft" align="right" valign="top"><a id="ae764a7998c1d99c3d090664901f350f0" name="ae764a7998c1d99c3d090664901f350f0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>FermiLevel</b> () const</td></tr>
<tr class="memdesc:ae764a7998c1d99c3d090664901f350f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns energy location of the "Fermi Level", - energy half way between core/valence. Defined: 0.5*( max(e_core) + min(e_valence)). Should be -ve. <br /></td></tr>
<tr class="separator:ae764a7998c1d99c3d090664901f350f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f3e32b0b49ce99dbfb7dbfba8cc7a1" id="r_a36f3e32b0b49ce99dbfb7dbfba8cc7a1"><td class="memItemLeft" align="right" valign="top"><a id="a36f3e32b0b49ce99dbfb7dbfba8cc7a1" name="a36f3e32b0b49ce99dbfb7dbfba8cc7a1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>energy_gap</b> () const</td></tr>
<tr class="memdesc:a36f3e32b0b49ce99dbfb7dbfba8cc7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Energy gap between lowest valence + highest core state: e(v) - e(c) [should be positive]. <br /></td></tr>
<tr class="separator:a36f3e32b0b49ce99dbfb7dbfba8cc7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae1dac145d79df6ed23600b0588da1e" id="r_a4ae1dac145d79df6ed23600b0588da1e"><td class="memItemLeft" align="right" valign="top"><a id="a4ae1dac145d79df6ed23600b0588da1e" name="a4ae1dac145d79df6ed23600b0588da1e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>coreConfiguration</b> () const</td></tr>
<tr class="memdesc:a4ae1dac145d79df6ed23600b0588da1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns full core configuration. <br /></td></tr>
<tr class="separator:a4ae1dac145d79df6ed23600b0588da1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7206fa0868e18ef7e2b6e13c0d969d" id="r_a7e7206fa0868e18ef7e2b6e13c0d969d"><td class="memItemLeft" align="right" valign="top"><a id="a7e7206fa0868e18ef7e2b6e13c0d969d" name="a7e7206fa0868e18ef7e2b6e13c0d969d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>coreConfiguration_nice</b> () const</td></tr>
<tr class="memdesc:a7e7206fa0868e18ef7e2b6e13c0d969d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns core configuration, in nice output notation. <br /></td></tr>
<tr class="separator:a7e7206fa0868e18ef7e2b6e13c0d969d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd94450e44598ec2605a36b468317ba" id="r_aafd94450e44598ec2605a36b468317ba"><td class="memItemLeft" align="right" valign="top"><a id="aafd94450e44598ec2605a36b468317ba" name="aafd94450e44598ec2605a36b468317ba"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>atom</b> () const</td></tr>
<tr class="memdesc:aafd94450e44598ec2605a36b468317ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">String of atom info (e.g., "Cs, Z=55, A=133") <br /></td></tr>
<tr class="separator:aafd94450e44598ec2605a36b468317ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfcac1486b376cd770c170f3ed96b41" id="r_a6bfcac1486b376cd770c170f3ed96b41"><td class="memItemLeft" align="right" valign="top"><a id="a6bfcac1486b376cd770c170f3ed96b41" name="a6bfcac1486b376cd770c170f3ed96b41"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>atomicSymbol</b> () const</td></tr>
<tr class="memdesc:a6bfcac1486b376cd770c170f3ed96b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">e.g., "Cs" <br /></td></tr>
<tr class="separator:a6bfcac1486b376cd770c170f3ed96b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407659d98aa3f8c87035ab786cb1ed81" id="r_a407659d98aa3f8c87035ab786cb1ed81"><td class="memItemLeft" align="right" valign="top"><a id="a407659d98aa3f8c87035ab786cb1ed81" name="a407659d98aa3f8c87035ab786cb1ed81"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>identity</b> () const</td></tr>
<tr class="memdesc:a407659d98aa3f8c87035ab786cb1ed81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic symbol, including core ionisation degree and run_label. <br /></td></tr>
<tr class="separator:a407659d98aa3f8c87035ab786cb1ed81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dfeebe30e21668643ed56b19e73b56" id="r_a59dfeebe30e21668643ed56b19e73b56"><td class="memItemLeft" align="right" valign="top"><a id="a59dfeebe30e21668643ed56b19e73b56" name="a59dfeebe30e21668643ed56b19e73b56"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ion_degree</b> (int num_val) const</td></tr>
<tr class="memdesc:a59dfeebe30e21668643ed56b19e73b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">0 for neutral, 1 for singly-ionised etc. <br /></td></tr>
<tr class="separator:a59dfeebe30e21668643ed56b19e73b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7064b45ef5ce6b32752443579fad35c7" id="r_a7064b45ef5ce6b32752443579fad35c7"><td class="memItemLeft" align="right" valign="top"><a id="a7064b45ef5ce6b32752443579fad35c7" name="a7064b45ef5ce6b32752443579fad35c7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>ion_symbol</b> (int num_val) const</td></tr>
<tr class="memdesc:a7064b45ef5ce6b32752443579fad35c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">I for neutral, II for singly-ionised etc. <br /></td></tr>
<tr class="separator:a7064b45ef5ce6b32752443579fad35c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e72272c10fd5b60add76bc8e57e1d71" id="r_a4e72272c10fd5b60add76bc8e57e1d71"><td class="memItemLeft" align="right" valign="top"><a id="a4e72272c10fd5b60add76bc8e57e1d71" name="a4e72272c10fd5b60add76bc8e57e1d71"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Zion</b> () const</td></tr>
<tr class="memdesc:a4e72272c10fd5b60add76bc8e57e1d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effective charge (for core) = Z-N_core. <br /></td></tr>
<tr class="separator:a4e72272c10fd5b60add76bc8e57e1d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabea2bcc724a931e139f4f9a7e80ec9" id="r_aaabea2bcc724a931e139f4f9a7e80ec9"><td class="memItemLeft" align="right" valign="top"><a id="aaabea2bcc724a931e139f4f9a7e80ec9" name="aaabea2bcc724a931e139f4f9a7e80ec9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printCore</b> () const</td></tr>
<tr class="memdesc:aaabea2bcc724a931e139f4f9a7e80ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints table of core orbitals + energies etc. <br /></td></tr>
<tr class="separator:aaabea2bcc724a931e139f4f9a7e80ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188d1b21e04a394d5ff1ed7af5251083" id="r_a188d1b21e04a394d5ff1ed7af5251083"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a188d1b21e04a394d5ff1ed7af5251083">printValence</a> (const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;tmp_orbitals={}) const</td></tr>
<tr class="memdesc:a188d1b21e04a394d5ff1ed7af5251083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints table of valence orbitals + energies etc.  <br /></td></tr>
<tr class="separator:a188d1b21e04a394d5ff1ed7af5251083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a5f8afe8f4db1628c1ba52816d2b36" id="r_ae8a5f8afe8f4db1628c1ba52816d2b36"><td class="memItemLeft" align="right" valign="top"><a id="ae8a5f8afe8f4db1628c1ba52816d2b36" name="ae8a5f8afe8f4db1628c1ba52816d2b36"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printBasis</b> (const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;the_basis) const</td></tr>
<tr class="memdesc:ae8a5f8afe8f4db1628c1ba52816d2b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints table of Basis/Spectrum orbitals, compares to HF orbitals. <br /></td></tr>
<tr class="separator:ae8a5f8afe8f4db1628c1ba52816d2b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab31789fb358324bf35331455688b6cb" id="r_aab31789fb358324bf35331455688b6cb"><td class="memItemLeft" align="right" valign="top"><a id="aab31789fb358324bf35331455688b6cb" name="aab31789fb358324bf35331455688b6cb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInCore</b> (int n, int k) const</td></tr>
<tr class="memdesc:aab31789fb358324bf35331455688b6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a state is in the core (or valence) list. <br /></td></tr>
<tr class="separator:aab31789fb358324bf35331455688b6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc58b95259bb712e40f69ecec6653ee3" id="r_afc58b95259bb712e40f69ecec6653ee3"><td class="memItemLeft" align="right" valign="top"><a id="afc58b95259bb712e40f69ecec6653ee3" name="afc58b95259bb712e40f69ecec6653ee3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInValence</b> (int n, int k) const</td></tr>
<tr class="separator:afc58b95259bb712e40f69ecec6653ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585c5708dd412db44cc306ee49b5d284" id="r_a585c5708dd412db44cc306ee49b5d284"><td class="memItemLeft" align="right" valign="top"><a id="a585c5708dd412db44cc306ee49b5d284" name="a585c5708dd412db44cc306ee49b5d284"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>coreDensity</b> () const</td></tr>
<tr class="memdesc:a585c5708dd412db44cc306ee49b5d284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates rho(r) = sum_c psi^2(r) for core states, c={n,k,m}. <br /></td></tr>
<tr class="separator:a585c5708dd412db44cc306ee49b5d284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f82c43a6c44abb081ff312d58d2490" id="r_a28f82c43a6c44abb081ff312d58d2490"><td class="memItemLeft" align="right" valign="top"><a id="a28f82c43a6c44abb081ff312d58d2490" name="a28f82c43a6c44abb081ff312d58d2490"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>coreEnergyHF</b> () const</td></tr>
<tr class="memdesc:a28f82c43a6c44abb081ff312d58d2490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates HF core energy (doesn't include magnetic QED?) <br /></td></tr>
<tr class="separator:a28f82c43a6c44abb081ff312d58d2490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf79d11f427d53683cd1b3586a62fa47" id="r_acf79d11f427d53683cd1b3586a62fa47"><td class="memItemLeft" align="right" valign="top"><a id="acf79d11f427d53683cd1b3586a62fa47" name="acf79d11f427d53683cd1b3586a62fa47"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_HF</b> (const std::string &amp;method=&quot;HartreeFock&quot;, const double x_Breit=0.0, const std::string &amp;in_core=&quot;&quot;, double eps_HF=1.0e-13, bool print=true)</td></tr>
<tr class="memdesc:acf79d11f427d53683cd1b3586a62fa47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises HF object and populates core orbitals (does not solve HF equations) <br /></td></tr>
<tr class="separator:acf79d11f427d53683cd1b3586a62fa47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1694e763b9dab8dbea8832eb5f1ace66" id="r_a1694e763b9dab8dbea8832eb5f1ace66"><td class="memItemLeft" align="right" valign="top"><a id="a1694e763b9dab8dbea8832eb5f1ace66" name="a1694e763b9dab8dbea8832eb5f1ace66"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>solve_core</b> (bool print=true)</td></tr>
<tr class="memdesc:a1694e763b9dab8dbea8832eb5f1ace66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs hartree-Fock procedure for core. <br /></td></tr>
<tr class="separator:a1694e763b9dab8dbea8832eb5f1ace66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b6f02e7d753e6db7ce0f13cbf65610" id="r_ae8b6f02e7d753e6db7ce0f13cbf65610"><td class="memItemLeft" align="right" valign="top"><a id="ae8b6f02e7d753e6db7ce0f13cbf65610" name="ae8b6f02e7d753e6db7ce0f13cbf65610"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>solve_core</b> (const std::string &amp;method, const double x_Breit=0.0, const std::string &amp;in_core=&quot;&quot;, double eps_HF=1.0e-13, bool print=true)</td></tr>
<tr class="memdesc:ae8b6f02e7d753e6db7ce0f13cbf65610"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version will first set_HF(), then solve_core() <br /></td></tr>
<tr class="separator:ae8b6f02e7d753e6db7ce0f13cbf65610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101757ec201b7a6f094a5f1522b9defb" id="r_a101757ec201b7a6f094a5f1522b9defb"><td class="memItemLeft" align="right" valign="top"><a id="a101757ec201b7a6f094a5f1522b9defb" name="a101757ec201b7a6f094a5f1522b9defb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>solve_valence</b> (const std::string &amp;in_valence_str=&quot;&quot;, const bool print=true)</td></tr>
<tr class="memdesc:a101757ec201b7a6f094a5f1522b9defb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs hartree-Fock procedure for valence: note: poplulates valnece. <br /></td></tr>
<tr class="separator:a101757ec201b7a6f094a5f1522b9defb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e01457a00c7662bb557e26c0099197" id="r_ad2e01457a00c7662bb557e26c0099197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ad2e01457a00c7662bb557e26c0099197">solve_exotic</a> (const std::string &amp;in_exotic_str, double mass=<a class="el" href="namespacePhysConst.html#ac5ad5179bea7381179c63c67bccb39cb">PhysConst::m_muon</a>, bool print=true)</td></tr>
<tr class="memdesc:ad2e01457a00c7662bb557e26c0099197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves for exotic atoms (e.g., muonic), including screening. Resulting states are included in valence; the screening also updates core.  <br /></td></tr>
<tr class="separator:ad2e01457a00c7662bb557e26c0099197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb1d340794e7d2a2afaa2e9184ff4c6" id="r_addb1d340794e7d2a2afaa2e9184ff4c6"><td class="memItemLeft" align="right" valign="top"><a id="addb1d340794e7d2a2afaa2e9184ff4c6" name="addb1d340794e7d2a2afaa2e9184ff4c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>hartreeFockBrueckner</b> (const bool print=true)</td></tr>
<tr class="memdesc:addb1d340794e7d2a2afaa2e9184ff4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms Bruckner valence orbitals: (H_hf + Sigma)|nk&gt; = e|nk&gt;. Replaces existing valence states. <br /></td></tr>
<tr class="separator:addb1d340794e7d2a2afaa2e9184ff4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c8fd9c5768cf18ddb2427f57b8d1b1" id="r_a09c8fd9c5768cf18ddb2427f57b8d1b1"><td class="memItemLeft" align="right" valign="top"><a id="a09c8fd9c5768cf18ddb2427f57b8d1b1" name="a09c8fd9c5768cf18ddb2427f57b8d1b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fitSigma_hfBrueckner</b> (const std::string &amp;valence_list, const std::vector&lt; double &gt; &amp;fit_energies)</td></tr>
<tr class="memdesc:a09c8fd9c5768cf18ddb2427f57b8d1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">First, fits Sigma to energies, then forms fitted Brueckner orbitals. <br /></td></tr>
<tr class="separator:a09c8fd9c5768cf18ddb2427f57b8d1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e94127825119943d41752e0ab1d3603" id="r_a6e94127825119943d41752e0ab1d3603"><td class="memItemLeft" align="right" valign="top"><a id="a6e94127825119943d41752e0ab1d3603" name="a6e94127825119943d41752e0ab1d3603"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>radiativePotential</b> (<a class="el" href="structQED_1_1RadPot_1_1Scale.html">QED::RadPot::Scale</a> s, double rcut, double scale_rN, const std::vector&lt; double &gt; &amp;x_spd, bool do_readwrite=true, bool print=true)</td></tr>
<tr class="memdesc:a6e94127825119943d41752e0ab1d3603"><td class="mdescLeft">&#160;</td><td class="mdescRight">OLD: deprecated. <br /></td></tr>
<tr class="separator:a6e94127825119943d41752e0ab1d3603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c5973bd714a32bef87bb434687917b" id="r_af4c5973bd714a32bef87bb434687917b"><td class="memItemLeft" align="right" valign="top"><a id="af4c5973bd714a32bef87bb434687917b" name="af4c5973bd714a32bef87bb434687917b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>radiativePotential</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;qed_input, bool do_readwrite, bool print)</td></tr>
<tr class="memdesc:af4c5973bd714a32bef87bb434687917b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates radiative potential, adds to HF potential. <br /></td></tr>
<tr class="separator:af4c5973bd714a32bef87bb434687917b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b4000c0b43b5437b9cb7acae829c90" id="r_a10b4000c0b43b5437b9cb7acae829c90"><td class="memItemLeft" align="right" valign="top"><a id="a10b4000c0b43b5437b9cb7acae829c90" name="a10b4000c0b43b5437b9cb7acae829c90"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>formBasis</b> (const SplineBasis::Parameters &amp;params)</td></tr>
<tr class="memdesc:a10b4000c0b43b5437b9cb7acae829c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates + populates basis [see BSplineBasis]. <br /></td></tr>
<tr class="separator:a10b4000c0b43b5437b9cb7acae829c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854d9e30f51b7978eb01d140bba65893" id="r_a854d9e30f51b7978eb01d140bba65893"><td class="memItemLeft" align="right" valign="top"><a id="a854d9e30f51b7978eb01d140bba65893" name="a854d9e30f51b7978eb01d140bba65893"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>formSpectrum</b> (const SplineBasis::Parameters &amp;params)</td></tr>
<tr class="memdesc:a854d9e30f51b7978eb01d140bba65893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates + populates Spectrum [see BSplineBasis]. <br /></td></tr>
<tr class="separator:a854d9e30f51b7978eb01d140bba65893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8baf0e156f1826e44d25d6de1e376fad" id="r_a8baf0e156f1826e44d25d6de1e376fad"><td class="memItemLeft" align="right" valign="top"><a id="a8baf0e156f1826e44d25d6de1e376fad" name="a8baf0e156f1826e44d25d6de1e376fad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>formSigma</b> (int nmin_core=1, int nmin_core_F=1, double r0=1.0e-4, double rmax=30.0, int stride=4, bool each_valence=false, bool include_G=false, bool include_Breit=false, int n_max_breit=0, const std::vector&lt; double &gt; &amp;lambdas={}, const std::vector&lt; double &gt; &amp;fk={}, const std::vector&lt; double &gt; &amp;etak={}, const std::string &amp;in_fname=&quot;&quot;, const std::string &amp;out_fname=&quot;&quot;, bool FeynmanQ=false, bool ScreeningQ=false, bool holeParticleQ=false, int lmax=6, double omre=-0.2, double w0=0.01, double wratio=1.5, const std::optional&lt; <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &gt; &amp;ek=std::nullopt)</td></tr>
<tr class="memdesc:a8baf0e156f1826e44d25d6de1e376fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms + stores correlation potential Sigma. <br /></td></tr>
<tr class="separator:a8baf0e156f1826e44d25d6de1e376fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421ef0086c7d2a879947bc2691b7bfbc" id="r_a421ef0086c7d2a879947bc2691b7bfbc"><td class="memItemLeft" align="right" valign="top"><a id="a421ef0086c7d2a879947bc2691b7bfbc" name="a421ef0086c7d2a879947bc2691b7bfbc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copySigma</b> (const MBPT::CorrelationPotential *const <a class="el" href="classWavefunction.html#a7d145ed8d246f74130b22c3db9bd1eba">Sigma</a>)</td></tr>
<tr class="separator:a421ef0086c7d2a879947bc2691b7bfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23a70d8cb483ccd17a025e1b0ffd25c" id="r_ac23a70d8cb483ccd17a025e1b0ffd25c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#ac23a70d8cb483ccd17a025e1b0ffd25c">update_Vnuc</a> (const std::vector&lt; double &gt; &amp;v_new)</td></tr>
<tr class="memdesc:ac23a70d8cb483ccd17a025e1b0ffd25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows extra potential to be added to Vnuc (updates both in Wavefunction.  <br /></td></tr>
<tr class="separator:ac23a70d8cb483ccd17a025e1b0ffd25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e99495299b73cd5ff9dd2f1f4b22a66" id="r_a2e99495299b73cd5ff9dd2f1f4b22a66"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWavefunction.html#a2e99495299b73cd5ff9dd2f1f4b22a66">lminmax_core_range</a> (int l, double eps=0.0) const</td></tr>
<tr class="memdesc:a2e99495299b73cd5ff9dd2f1f4b22a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns [min,max] r values for which the core density (given l) is larger than cutoff (= eps*max_value)  <br /></td></tr>
<tr class="separator:a2e99495299b73cd5ff9dd2f1f4b22a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababc5fbcf192d52242592d4c3b6b8fbe" id="r_ababc5fbcf192d52242592d4c3b6b8fbe"><td class="memItemLeft" align="right" valign="top"><a id="ababc5fbcf192d52242592d4c3b6b8fbe" name="ababc5fbcf192d52242592d4c3b6b8fbe"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>H0ab</b> (const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb) const</td></tr>
<tr class="memdesc:ababc5fbcf192d52242592d4c3b6b8fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns &lt;a|H|b&gt; for Hamiltonian H (inludes Rad.pot, NOT sigma, Breit, or exchange!) <br /></td></tr>
<tr class="separator:ababc5fbcf192d52242592d4c3b6b8fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2b7bc99337624a10625bf8654c5bfe" id="r_a1b2b7bc99337624a10625bf8654c5bfe"><td class="memItemLeft" align="right" valign="top"><a id="a1b2b7bc99337624a10625bf8654c5bfe" name="a1b2b7bc99337624a10625bf8654c5bfe"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>H0ab</b> (const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;dFa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;dFb) const</td></tr>
<tr class="memdesc:a1b2b7bc99337624a10625bf8654c5bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns &lt;a|H|b&gt; for Hamiltonian H (inludes Rad.pot, NOT sigma, Breit, or exchange!) <br /></td></tr>
<tr class="separator:a1b2b7bc99337624a10625bf8654c5bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc490d63cc2a28c8aee6f803fd26731" id="r_aedc490d63cc2a28c8aee6f803fd26731"><td class="memItemLeft" align="right" valign="top"><a id="aedc490d63cc2a28c8aee6f803fd26731" name="aedc490d63cc2a28c8aee6f803fd26731"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Hab</b> (const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb) const</td></tr>
<tr class="separator:aedc490d63cc2a28c8aee6f803fd26731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2a0f0b79bb87d7266dba526342f1ed" id="r_abd2a0f0b79bb87d7266dba526342f1ed"><td class="memItemLeft" align="right" valign="top"><a id="abd2a0f0b79bb87d7266dba526342f1ed" name="abd2a0f0b79bb87d7266dba526342f1ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ConfigurationInteraction</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input)</td></tr>
<tr class="memdesc:abd2a0f0b79bb87d7266dba526342f1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the CI+MBPT routines; stores wavefunctions. <br /></td></tr>
<tr class="separator:abd2a0f0b79bb87d7266dba526342f1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da1efd1927edb6843ac9f3916ff414d" id="r_a4da1efd1927edb6843ac9f3916ff414d"><td class="memItemLeft" align="right" valign="top"><a id="a4da1efd1927edb6843ac9f3916ff414d" name="a4da1efd1927edb6843ac9f3916ff414d"></a>
nlohmann::json&#160;</td><td class="memItemRight" valign="bottom"><b>output_to_json</b> (const std::string &amp;out_name=&quot;ampsci_output.json&quot;)</td></tr>
<tr class="memdesc:a4da1efd1927edb6843ac9f3916ff414d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes wavefunction information to json file; if out_name given, will print to that file. <br /></td></tr>
<tr class="separator:a4da1efd1927edb6843ac9f3916ff414d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stores Wavefunction (set of valence orbitals, grid, HF etc.) </p>
<dl class="section user"><dt>Construction:</dt><dd><ul>
<li>Set of GridParameters [see Maths/Grid]</li>
<li>Set of Nuclear::Nucleus [see Physics/NuclearPotentials]</li>
<li>var_alpha = \(\lambda\), \(\alpha = \lambda\alpha_0\)</li>
<li>run_label: Optional label for output identity - for distinguishing outputs with different parameters </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2ebe5ad5f71d03f2b34c2bad30c48b2e" name="a2ebe5ad5f71d03f2b34c2bad30c48b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebe5ad5f71d03f2b34c2bad30c48b2e">&#9670;&#160;</a></span>getState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> * Wavefunction::getState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds requested state; returns nullptr if not found. </p>
<p>is_valence is optional out-parameter; tells you where orb was found </p>

</div>
</div>
<a id="a2e99495299b73cd5ff9dd2f1f4b22a66" name="a2e99495299b73cd5ff9dd2f1f4b22a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e99495299b73cd5ff9dd2f1f4b22a66">&#9670;&#160;</a></span>lminmax_core_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; double, double &gt; Wavefunction::lminmax_core_range </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns [min,max] r values for which the core density (given l) is larger than cutoff (= eps*max_value) </p>
<p>Returns the r values (au) for which the value of rho = \sum|psi^2|(r) drops below cutoff. Sum goes over all m for given l. Cut-off defined as eps*max, where max is maximum value for rho(r). Set l&lt;0 to get for all l (entire core) </p>

</div>
</div>
<a id="a188d1b21e04a394d5ff1ed7af5251083" name="a188d1b21e04a394d5ff1ed7af5251083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188d1b21e04a394d5ff1ed7af5251083">&#9670;&#160;</a></span>printValence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wavefunction::printValence </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp_orbitals</em> = <code>{}</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints table of valence orbitals + energies etc. </p>
<p>Can optionally give it any list of orbitals to print </p>

</div>
</div>
<a id="ad2e01457a00c7662bb557e26c0099197" name="ad2e01457a00c7662bb557e26c0099197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e01457a00c7662bb557e26c0099197">&#9670;&#160;</a></span>solve_exotic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wavefunction::solve_exotic </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>in_exotic_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mass</em> = <code><a class="el" href="namespacePhysConst.html#ac5ad5179bea7381179c63c67bccb39cb">PhysConst::m_muon</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves for exotic atoms (e.g., muonic), including screening. Resulting states are included in valence; the screening also updates core. </p>
<p>Note: The exotic states are just added to the valence list, so they can be used more simply with all the modules. However, be careful; for example, RPA will now be meaningless! </p>

</div>
</div>
<a id="ac23a70d8cb483ccd17a025e1b0ffd25c" name="ac23a70d8cb483ccd17a025e1b0ffd25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23a70d8cb483ccd17a025e1b0ffd25c">&#9670;&#160;</a></span>update_Vnuc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Wavefunction::update_Vnuc </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows extra potential to be added to Vnuc (updates both in Wavefunction. </p>
<p>nb: two versions of Vnuc...</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Wavefunction/<a class="el" href="Wavefunction_8hpp_source.html">Wavefunction.hpp</a></li>
<li>Wavefunction/<b>Wavefunction.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 27 2025 01:28:43 for ampsci by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
