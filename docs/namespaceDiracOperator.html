<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="light-mode">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=9" />
        <meta name="generator" content="Doxygen 1.9.8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>ampsci:
            DiracOperator Namespace Reference</title>
        <link href="tabs.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="blue-theme.css" rel="stylesheet" type="text/css"/>
        <!-- ... other metadata & script includes ... -->
        <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeFragmentCopyButton.init()
        </script>
        <!-- <script>
            document.documentElement.classList.add("light-mode");
        </script> -->
    </head>
    <body>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div id="titlearea">
                <table cellspacing="0" cellpadding="0">
                    <tbody>
                        <tr style="height: 56px;">
                            <td id="projectalign" style="padding-left: 0.5em;">
                                <div id="projectname">ampsci
                                </div>
                                <div
                                    id="projectbrief">High-precision calculations for one- and two-valence atomic systems</div>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceDiracOperator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">DiracOperator Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Dirac Operators: General + derived.  
<a href="namespaceDiracOperator.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDiracOperator_1_1Hyperfine" id="r_namespaceDiracOperator_1_1Hyperfine"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator_1_1Hyperfine.html">Hyperfine</a></td></tr>
<tr class="memdesc:namespaceDiracOperator_1_1Hyperfine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions for F(r) [nuclear magnetisation distribution] and similar. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDiracOperator_1_1multipole" id="r_namespaceDiracOperator_1_1multipole"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator_1_1multipole.html">multipole</a></td></tr>
<tr class="memdesc:namespaceDiracOperator_1_1multipole"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions for the multipole operators. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1AEk.html">AEk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axial electric multipole operator: \( A^E_K = T^{(+1)}_K(q)\gamma^5 \).  <a href="classDiracOperator_1_1AEk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1AEk__lowq.html">AEk_lowq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low qr form of Axial electric multipole operator: \( A^E_K = T^{(+1)}_K(q)\gamma^5\).  <a href="classDiracOperator_1_1AEk__lowq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1ALk.html">ALk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axial longitudinal multipole operator: \( A^L_K = T^{(-1)}_K(q)\gamma^5 \).  <a href="classDiracOperator_1_1ALk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1ALk__lowq.html">ALk_lowq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low qr form of Axial longitudinal multipole operator: \( A^L_K = T^{(-1)}_K(q)\gamma^5\).  <a href="classDiracOperator_1_1ALk__lowq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1AMk.html">AMk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axial magnetic multipole operator: \( A^M_K = T^{(0)}_K(q)\gamma^5 \).  <a href="classDiracOperator_1_1AMk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1AMk__lowq.html">AMk_lowq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low qr form of Axial magnetic multipole operator: \( A^M_K = T^{(0)}_K(q)\gamma^5\).  <a href="classDiracOperator_1_1AMk__lowq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1dr.html">dr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">radial derivative operator  <a href="classDiracOperator_1_1dr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1E1.html">E1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Electric dipole operator: -|e|r = -er.  <a href="classDiracOperator_1_1E1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1E1v.html">E1v</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Electric dipole operator, v-form: \( \frac{ie}{\omega \alpha} \vec{\alpha}\).  <a href="classDiracOperator_1_1E1v.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1Ek.html">Ek</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">E^k (electric multipole) operator.  <a href="classDiracOperator_1_1Ek.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1fieldshift.html">fieldshift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Field shift operator, (e.g.) dV = V(r+dr) - V(r)  <a href="classDiracOperator_1_1fieldshift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1g0jL.html">g0jL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix element of tensor operator: gamma^0 J_L(qr) C^L.  <a href="classDiracOperator_1_1g0jL.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1hfs.html">hfs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Units: Assumes nuclear moment in units of powers of nuclear magnetons and/or barns - muN*b^(k-1)/2 for magnetic, and b^k/2 for electric.  <a href="classDiracOperator_1_1hfs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1ig0g5jL.html">ig0g5jL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix element of tensor operator: i gamma^0gamma^5 J_L(qr) C^L. nb: i makes ME real.  <a href="classDiracOperator_1_1ig0g5jL.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1ig5jL.html">ig5jL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix element of tensor operator: i gamma^5 J_L(qr) C^L. nb: i makes ME real.  <a href="classDiracOperator_1_1ig5jL.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDiracOperator_1_1IntM4x4.html">IntM4x4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">4x4 Integer matrix (for Gamma/Pauli). Can be real or imag. Not mixed.  <a href="structDiracOperator_1_1IntM4x4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1j.html">j</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">j (total angular momentum) operator  <a href="classDiracOperator_1_1j.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1jL.html">jL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix element of tensor operator: J_L(qr)*C^L.  <a href="classDiracOperator_1_1jL.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1l.html">l</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">l (orbital angular momentum) operator  <a href="classDiracOperator_1_1l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1M1.html">M1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magnetic dipole operator: &lt;a||M1||b&gt;  <a href="classDiracOperator_1_1M1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1M1nr.html">M1nr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magnetic dipole operator, in non-relativistic form: M1 = L + 2S.  <a href="classDiracOperator_1_1M1nr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1MLVP.html">MLVP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magnetic loop vacuum polarisation (Uehling vertex)  <a href="classDiracOperator_1_1MLVP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1NullOperator.html">NullOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Speacial operator: 0.  <a href="classDiracOperator_1_1NullOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1Phi5k.html">Phi5k</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporal component of the axial vector multipole operator: \( \Theta_K = \Phi^5_K = t^K(q)\gamma^5 \).  <a href="classDiracOperator_1_1Phi5k.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1Phi5k__lowq.html">Phi5k_lowq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low qr form of Temporal component of the axial vector multipole operator: \( \Theta_K = \Phi^5_K = t^K(q)\gamma^5\) . NOTE: If K=0, omega should be (ea-eb); for K=1 should be q = alpha*omega!  <a href="classDiracOperator_1_1Phi5k__lowq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1Phik.html">Phik</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporal component of the vector multipole operator: \( \Phi_K = t^K(q) \).  <a href="classDiracOperator_1_1Phik.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1Phik__lowq.html">Phik_lowq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low qr form of Temporal component of the vector multipole operator: \( \Phi_K = t^K(q)\).  <a href="classDiracOperator_1_1Phik__lowq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1PNCnsi.html">PNCnsi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nuclear-spin independent PNC operator (Qw)  <a href="classDiracOperator_1_1PNCnsi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1RadialF.html">RadialF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General function of r, even scalar operator.  <a href="classDiracOperator_1_1RadialF.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1s.html">s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">s (spin) operator  <a href="classDiracOperator_1_1s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1S5k.html">S5k</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudoscalar multipole operator: \( P_K = S^5_K = t^K(q)(i\gamma^0\gamma^5) \).  <a href="classDiracOperator_1_1S5k.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1S5k__lowq.html">S5k_lowq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low qr form of Pseudoscalar multipole operator: \( P_K = S^5_K = t^K(q)(i\gamma^0\gamma^5)\) NOTE: If K=0, omega should be (ea-eb); for K=1 should be q = alpha*omega!  <a href="classDiracOperator_1_1S5k__lowq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1ScalarOperator.html">ScalarOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Speacial case for scalar operator.  <a href="classDiracOperator_1_1ScalarOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1Sk.html">Sk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multipole operator: \( S_K = t^K(q)\gamma^0 \).  <a href="classDiracOperator_1_1Sk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1Sk__lowq.html">Sk_lowq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low qr form of Scalar multipole operator: \( S_K = t^K(q)\gamma^0\).  <a href="classDiracOperator_1_1Sk__lowq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1TensorOperator.html">TensorOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General operator (virtual base class); operators derive from this.  <a href="classDiracOperator_1_1TensorOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1VEk.html">VEk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector electric multipole (V-form) operator: \( V^E_K = T^{(+1)}_K(q) \).  <a href="classDiracOperator_1_1VEk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1VEk__Len.html">VEk_Len</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector electric multipole (transition) operator, Length-form: ( \( T^{(+1),{\rm Len}}_K \) ).  <a href="classDiracOperator_1_1VEk__Len.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1VEk__lowq.html">VEk_lowq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low qr form of Vector electric. Only for K=1 (zero otherwise)  <a href="classDiracOperator_1_1VEk__lowq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1VertexQED.html">VertexQED</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effective VertexQED operator.  <a href="classDiracOperator_1_1VertexQED.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1VLk.html">VLk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector longitudinal multipole operator (V-form): \( V^L_K = T^{(-1)}_K(q) \).  <a href="classDiracOperator_1_1VLk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1VLk__lowq.html">VLk_lowq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low qr form of Vector longitudanal.  <a href="classDiracOperator_1_1VLk__lowq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1VMk.html">VMk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector magnetic multipole operator: \( V^M_K = T^{(0)}_K(q) \).  <a href="classDiracOperator_1_1VMk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1VMk__lowq.html">VMk_lowq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low qr form of Vector magnetic. Only for K=1 (zero otherwise)  <a href="classDiracOperator_1_1VMk__lowq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDiracOperator_1_1Vrad.html">Vrad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flambaum-ginges radiative potential operator.  <a href="classDiracOperator_1_1Vrad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9747ab0a95ff7b9b7f192ce9b0923372" id="r_a9747ab0a95ff7b9b7f192ce9b0923372"><td class="memItemLeft" align="right" valign="top"><a id="a9747ab0a95ff7b9b7f192ce9b0923372" name="a9747ab0a95ff7b9b7f192ce9b0923372"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>Parity</b> { <b>even</b>
, <b>odd</b>
, <b>blank</b>
 }</td></tr>
<tr class="separator:a9747ab0a95ff7b9b7f192ce9b0923372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82d9a7b33e75b838895a7d042e27007" id="r_ab82d9a7b33e75b838895a7d042e27007"><td class="memItemLeft" align="right" valign="top"><a id="ab82d9a7b33e75b838895a7d042e27007" name="ab82d9a7b33e75b838895a7d042e27007"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>Realness</b> { <b>real</b>
, <b>imaginary</b>
, <b>blank</b>
 }</td></tr>
<tr class="separator:ab82d9a7b33e75b838895a7d042e27007"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0cc7ae02da5ab35977397fa7a294210d" id="r_a0cc7ae02da5ab35977397fa7a294210d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#a0cc7ae02da5ab35977397fa7a294210d">generate</a> (std::string_view operator_name, const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;wf)</td></tr>
<tr class="memdesc:a0cc7ae02da5ab35977397fa7a294210d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unique_ptr (polymorphic) to the requested operator, with given properties.  <br /></td></tr>
<tr class="separator:a0cc7ae02da5ab35977397fa7a294210d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2087c8ca2d04129a80a0b39586a2463d" id="r_a2087c8ca2d04129a80a0b39586a2463d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#a2087c8ca2d04129a80a0b39586a2463d">list_operators</a> ()</td></tr>
<tr class="memdesc:a2087c8ca2d04129a80a0b39586a2463d"><td class="mdescLeft">&#160;</td><td class="mdescRight">List available operators.  <br /></td></tr>
<tr class="separator:a2087c8ca2d04129a80a0b39586a2463d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12419e161a5637fb748bc2d2bf77dfa" id="r_ae12419e161a5637fb748bc2d2bf77dfa"><td class="memItemLeft" align="right" valign="top"><a id="ae12419e161a5637fb748bc2d2bf77dfa" name="ae12419e161a5637fb748bc2d2bf77dfa"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_sigma_r</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;wf)</td></tr>
<tr class="separator:ae12419e161a5637fb748bc2d2bf77dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4059b18a006456db7759a77ed1a4ab" id="r_a0f4059b18a006456db7759a77ed1a4ab"><td class="memItemLeft" align="right" valign="top"><a id="a0f4059b18a006456db7759a77ed1a4ab" name="a0f4059b18a006456db7759a77ed1a4ab"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_E1</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;wf)</td></tr>
<tr class="separator:a0f4059b18a006456db7759a77ed1a4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef4ac2429dbe6b620a084c684c5d5ca" id="r_a6ef4ac2429dbe6b620a084c684c5d5ca"><td class="memItemLeft" align="right" valign="top"><a id="a6ef4ac2429dbe6b620a084c684c5d5ca" name="a6ef4ac2429dbe6b620a084c684c5d5ca"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_E1v</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;wf)</td></tr>
<tr class="separator:a6ef4ac2429dbe6b620a084c684c5d5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37541fd4488f7ef5c2cb78d3b273b87e" id="r_a37541fd4488f7ef5c2cb78d3b273b87e"><td class="memItemLeft" align="right" valign="top"><a id="a37541fd4488f7ef5c2cb78d3b273b87e" name="a37541fd4488f7ef5c2cb78d3b273b87e"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_E2</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;wf)</td></tr>
<tr class="separator:a37541fd4488f7ef5c2cb78d3b273b87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f7d98b6aa54dd1ea36e1523be177cf" id="r_a90f7d98b6aa54dd1ea36e1523be177cf"><td class="memItemLeft" align="right" valign="top"><a id="a90f7d98b6aa54dd1ea36e1523be177cf" name="a90f7d98b6aa54dd1ea36e1523be177cf"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_ialpha</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;)</td></tr>
<tr class="separator:a90f7d98b6aa54dd1ea36e1523be177cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f705b561c53fa8d029741c1140112c" id="r_a47f705b561c53fa8d029741c1140112c"><td class="memItemLeft" align="right" valign="top"><a id="a47f705b561c53fa8d029741c1140112c" name="a47f705b561c53fa8d029741c1140112c"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_Ek</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;wf)</td></tr>
<tr class="separator:a47f705b561c53fa8d029741c1140112c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccf497e09cf871508efa997fcc4d4ca" id="r_a2ccf497e09cf871508efa997fcc4d4ca"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#a2ccf497e09cf871508efa997fcc4d4ca">MultipoleOperator</a> (const <a class="el" href="classGrid.html">Grid</a> &amp;grid, int k, double omega, char type, char comp, bool low_q, const <a class="el" href="classSphericalBessel_1_1JL__table.html">SphericalBessel::JL_table</a> *jl=nullptr)</td></tr>
<tr class="memdesc:a2ccf497e09cf871508efa997fcc4d4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for relativistic multipole operators.  <br /></td></tr>
<tr class="separator:a2ccf497e09cf871508efa997fcc4d4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fefe7c9ac3765928493bda847eaeae" id="r_a03fefe7c9ac3765928493bda847eaeae"><td class="memItemLeft" align="right" valign="top"><a id="a03fefe7c9ac3765928493bda847eaeae" name="a03fefe7c9ac3765928493bda847eaeae"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_Multipole</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;wf)</td></tr>
<tr class="separator:a03fefe7c9ac3765928493bda847eaeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae424f48e960e9c68a19c1c70ff566d8b" id="r_ae424f48e960e9c68a19c1c70ff566d8b"><td class="memItemLeft" align="right" valign="top"><a id="ae424f48e960e9c68a19c1c70ff566d8b" name="ae424f48e960e9c68a19c1c70ff566d8b"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_fieldshift</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;wf)</td></tr>
<tr class="separator:ae424f48e960e9c68a19c1c70ff566d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818bd64a8e8df0a0ac079be2a2ac2b3b" id="r_a818bd64a8e8df0a0ac079be2a2ac2b3b"><td class="memItemLeft" align="right" valign="top"><a id="a818bd64a8e8df0a0ac079be2a2ac2b3b" name="a818bd64a8e8df0a0ac079be2a2ac2b3b"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_hfs</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;wf)</td></tr>
<tr class="separator:a818bd64a8e8df0a0ac079be2a2ac2b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee4e62bfb1e5b3dd49b3111ad460c55" id="r_a0ee4e62bfb1e5b3dd49b3111ad460c55"><td class="memItemLeft" align="right" valign="top"><a id="a0ee4e62bfb1e5b3dd49b3111ad460c55" name="a0ee4e62bfb1e5b3dd49b3111ad460c55"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_l</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;)</td></tr>
<tr class="separator:a0ee4e62bfb1e5b3dd49b3111ad460c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae6e0137ce7e813811986667794a37d" id="r_abae6e0137ce7e813811986667794a37d"><td class="memItemLeft" align="right" valign="top"><a id="abae6e0137ce7e813811986667794a37d" name="abae6e0137ce7e813811986667794a37d"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_s</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;)</td></tr>
<tr class="separator:abae6e0137ce7e813811986667794a37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bd753c003cc71cfa0fb2ad0f2754f8" id="r_a93bd753c003cc71cfa0fb2ad0f2754f8"><td class="memItemLeft" align="right" valign="top"><a id="a93bd753c003cc71cfa0fb2ad0f2754f8" name="a93bd753c003cc71cfa0fb2ad0f2754f8"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_M1</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;wf)</td></tr>
<tr class="separator:a93bd753c003cc71cfa0fb2ad0f2754f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9ee63be03b5fae8dcd779d7dacc07d" id="r_a8f9ee63be03b5fae8dcd779d7dacc07d"><td class="memItemLeft" align="right" valign="top"><a id="a8f9ee63be03b5fae8dcd779d7dacc07d" name="a8f9ee63be03b5fae8dcd779d7dacc07d"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_M1nr</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;)</td></tr>
<tr class="separator:a8f9ee63be03b5fae8dcd779d7dacc07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1524a0f05cbf4cf667706eebcd1c761" id="r_ad1524a0f05cbf4cf667706eebcd1c761"><td class="memItemLeft" align="right" valign="top"><a id="ad1524a0f05cbf4cf667706eebcd1c761" name="ad1524a0f05cbf4cf667706eebcd1c761"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_p</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;)</td></tr>
<tr class="separator:ad1524a0f05cbf4cf667706eebcd1c761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47769a86ddb19cab14e4d86da6db4aa" id="r_aa47769a86ddb19cab14e4d86da6db4aa"><td class="memItemLeft" align="right" valign="top"><a id="aa47769a86ddb19cab14e4d86da6db4aa" name="aa47769a86ddb19cab14e4d86da6db4aa"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_pnc</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;wf)</td></tr>
<tr class="separator:aa47769a86ddb19cab14e4d86da6db4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d6f368ca0089c48815d2abe5fcf6b6" id="r_ae0d6f368ca0089c48815d2abe5fcf6b6"><td class="memItemLeft" align="right" valign="top"><a id="ae0d6f368ca0089c48815d2abe5fcf6b6" name="ae0d6f368ca0089c48815d2abe5fcf6b6"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_Vrad</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;wf)</td></tr>
<tr class="separator:ae0d6f368ca0089c48815d2abe5fcf6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc4bfb6ba408b58606ec19df49c5192" id="r_accc4bfb6ba408b58606ec19df49c5192"><td class="memItemLeft" align="right" valign="top"><a id="accc4bfb6ba408b58606ec19df49c5192" name="accc4bfb6ba408b58606ec19df49c5192"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_MLVP</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;wf)</td></tr>
<tr class="separator:accc4bfb6ba408b58606ec19df49c5192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbfd2c4c37e10af146281a5652a993b" id="r_acdbfd2c4c37e10af146281a5652a993b"><td class="memItemLeft" align="right" valign="top"><a id="acdbfd2c4c37e10af146281a5652a993b" name="acdbfd2c4c37e10af146281a5652a993b"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_r</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;wf)</td></tr>
<tr class="separator:acdbfd2c4c37e10af146281a5652a993b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed6bef1ec4f260d467a3dc2cc3037c5" id="r_a7ed6bef1ec4f260d467a3dc2cc3037c5"><td class="memItemLeft" align="right" valign="top"><a id="a7ed6bef1ec4f260d467a3dc2cc3037c5" name="a7ed6bef1ec4f260d467a3dc2cc3037c5"></a>
std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_dr</b> (const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;input, const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;)</td></tr>
<tr class="separator:a7ed6bef1ec4f260d467a3dc2cc3037c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed793d98abb51ccddabee6bdcabb108" id="r_aeed793d98abb51ccddabee6bdcabb108"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#aeed793d98abb51ccddabee6bdcabb108">Pab</a> (double pm, const std::vector&lt; double &gt; &amp;t, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb)</td></tr>
<tr class="memdesc:aeed793d98abb51ccddabee6bdcabb108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pab function: Int[ (fa*gb + pm*ga*fb) * t(r) , dr]. pm = +/-1 (usually)  <br /></td></tr>
<tr class="separator:aeed793d98abb51ccddabee6bdcabb108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3e332040b784e97460e6b65890de73" id="r_a4e3e332040b784e97460e6b65890de73"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#a4e3e332040b784e97460e6b65890de73">Rab</a> (double pm, const std::vector&lt; double &gt; &amp;t, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb)</td></tr>
<tr class="memdesc:a4e3e332040b784e97460e6b65890de73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rab function: Int[ (fa*fb + pm*ga*gb) * t(r) , dr]. pm = +/-1 (usually)  <br /></td></tr>
<tr class="separator:a4e3e332040b784e97460e6b65890de73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0258429af93c59907b247ce777d6f92e" id="r_a0258429af93c59907b247ce777d6f92e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#a0258429af93c59907b247ce777d6f92e">Pab_rhs</a> (double pm, const std::vector&lt; double &gt; &amp;t, <a class="el" href="classDiracSpinor.html">DiracSpinor</a> *dF, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb, double A=1.0)</td></tr>
<tr class="memdesc:a0258429af93c59907b247ce777d6f92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pab_rhs function: dF_ab += A * t(r) * (g, pm*f) , pm=+/-1 (usually). NOTE: uses +=, so can combine. Ensure empty to begin.  <br /></td></tr>
<tr class="separator:a0258429af93c59907b247ce777d6f92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae265f3305c4912b1f4764eeac57d81" id="r_a8ae265f3305c4912b1f4764eeac57d81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#a8ae265f3305c4912b1f4764eeac57d81">Rab_rhs</a> (double pm, const std::vector&lt; double &gt; &amp;t, <a class="el" href="classDiracSpinor.html">DiracSpinor</a> *dF, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb, double A=1.0)</td></tr>
<tr class="memdesc:a8ae265f3305c4912b1f4764eeac57d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rab_rhs function: dF_ab += A * t(r) * (f, pm*g) , pm=+/-1 (usually). NOTE: uses +=, so can combine. Ensure empty to begin.  <br /></td></tr>
<tr class="separator:a8ae265f3305c4912b1f4764eeac57d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0428c4d99942d7ec8dffb17016029730" id="r_a0428c4d99942d7ec8dffb17016029730"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#a0428c4d99942d7ec8dffb17016029730">Vab</a> (const std::vector&lt; double &gt; &amp;t, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb)</td></tr>
<tr class="memdesc:a0428c4d99942d7ec8dffb17016029730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vab function: Int[ (fa*gb ) * t(r) , dr].  <br /></td></tr>
<tr class="separator:a0428c4d99942d7ec8dffb17016029730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c18225f0680e3d96d5f68ff44e3b47" id="r_a75c18225f0680e3d96d5f68ff44e3b47"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#a75c18225f0680e3d96d5f68ff44e3b47">Wab</a> (const std::vector&lt; double &gt; &amp;t, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb)</td></tr>
<tr class="memdesc:a75c18225f0680e3d96d5f68ff44e3b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wab function: Int[ (ga*fb ) * t(r) , dr].  <br /></td></tr>
<tr class="separator:a75c18225f0680e3d96d5f68ff44e3b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051262ad405cf60f7cf91799957c1709" id="r_a051262ad405cf60f7cf91799957c1709"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#a051262ad405cf60f7cf91799957c1709">Gab</a> (const std::vector&lt; double &gt; &amp;t, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb)</td></tr>
<tr class="memdesc:a051262ad405cf60f7cf91799957c1709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gab function: Int[ (ga*gb ) * t(r) , dr].  <br /></td></tr>
<tr class="separator:a051262ad405cf60f7cf91799957c1709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4731ae1fd713ae3569b91001477b1e3" id="r_aa4731ae1fd713ae3569b91001477b1e3"><td class="memItemLeft" align="right" valign="top"><a id="aa4731ae1fd713ae3569b91001477b1e3" name="aa4731ae1fd713ae3569b91001477b1e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Gab_rhs</b> (const std::vector&lt; double &gt; &amp;t, <a class="el" href="classDiracSpinor.html">DiracSpinor</a> *dF, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb, double a)</td></tr>
<tr class="separator:aa4731ae1fd713ae3569b91001477b1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc984427efaa054d9e690001b9540ee4" id="r_adc984427efaa054d9e690001b9540ee4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#adc984427efaa054d9e690001b9540ee4">Gab</a> (const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb)</td></tr>
<tr class="memdesc:adc984427efaa054d9e690001b9540ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gab = Int[ ga*gb , dr] - (just relativistic correction part of integral)  <br /></td></tr>
<tr class="separator:adc984427efaa054d9e690001b9540ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab170f4179f93e0aedc634775ed2ac2f7" id="r_ab170f4179f93e0aedc634775ed2ac2f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#ab170f4179f93e0aedc634775ed2ac2f7">Gab_rhs</a> (<a class="el" href="classDiracSpinor.html">DiracSpinor</a> *dF, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb, double a)</td></tr>
<tr class="memdesc:ab170f4179f93e0aedc634775ed2ac2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gab_rhs(r) += a*g_b(r). Note: uses += so may be sumulative.  <br /></td></tr>
<tr class="separator:ab170f4179f93e0aedc634775ed2ac2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324ff3ab6167f95c6f65bbcc97a628de" id="r_a324ff3ab6167f95c6f65bbcc97a628de"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#a324ff3ab6167f95c6f65bbcc97a628de">Pab</a> (double pm, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb)</td></tr>
<tr class="memdesc:a324ff3ab6167f95c6f65bbcc97a628de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pab[1] function: Int[ (fa*gb + pm*ga*fb) , dr]. pm = +/-1 (usually)  <br /></td></tr>
<tr class="separator:a324ff3ab6167f95c6f65bbcc97a628de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505727251d4b9f7d58eb19c3bc49893d" id="r_a505727251d4b9f7d58eb19c3bc49893d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#a505727251d4b9f7d58eb19c3bc49893d">Rab</a> (double pm, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fa, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb)</td></tr>
<tr class="memdesc:a505727251d4b9f7d58eb19c3bc49893d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rab[1] function: Int[ (fa*fb + pm*ga*gb) , dr] = Int[ (pm-1)*ga*gb) , dr]. NOTE: assumes NOT diagonal, using orthogonality condition.  <br /></td></tr>
<tr class="separator:a505727251d4b9f7d58eb19c3bc49893d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b31c03717c41f3757000dfb9046c7af" id="r_a4b31c03717c41f3757000dfb9046c7af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#a4b31c03717c41f3757000dfb9046c7af">Pab_rhs</a> (double pm, <a class="el" href="classDiracSpinor.html">DiracSpinor</a> *dF, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb, double A=1.0)</td></tr>
<tr class="memdesc:a4b31c03717c41f3757000dfb9046c7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pab_rhs[1] function: dF_ab += A * (g, pm*f) , pm=+/-1 (usually).  <br /></td></tr>
<tr class="separator:a4b31c03717c41f3757000dfb9046c7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77eb511ecedb2004e69bc0985a5bdbd" id="r_ae77eb511ecedb2004e69bc0985a5bdbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#ae77eb511ecedb2004e69bc0985a5bdbd">Rab_rhs</a> (double pm, <a class="el" href="classDiracSpinor.html">DiracSpinor</a> *dF, const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;Fb, double A=1.0)</td></tr>
<tr class="memdesc:ae77eb511ecedb2004e69bc0985a5bdbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rab_rhs[1] function: dF_ab += A * (f, pm*g) = dF_ab += A * (0, (pm-1)*g). NOTE: assumes NOT diagonal, using orthogonality condition.  <br /></td></tr>
<tr class="separator:ae77eb511ecedb2004e69bc0985a5bdbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8c816ffb9c46966c395c65f1fe1ae815" id="r_a8c816ffb9c46966c395c65f1fe1ae815"><td class="memItemLeft" align="right" valign="top">brief i&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDiracOperator.html#a8c816ffb9c46966c395c65f1fe1ae815">vec</a></td></tr>
<tr class="separator:a8c816ffb9c46966c395c65f1fe1ae815"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Dirac Operators: General + derived. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a0cc7ae02da5ab35977397fa7a294210d" name="a0cc7ae02da5ab35977397fa7a294210d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc7ae02da5ab35977397fa7a294210d">&#9670;&#160;</a></span>generate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt; DiracOperator::generate </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>operator_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIO_1_1InputBlock.html">IO::InputBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classWavefunction.html">Wavefunction</a> &amp;&#160;</td>
          <td class="paramname"><em>wf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a unique_ptr (polymorphic) to the requested operator, with given properties. </p>

</div>
</div>
<a id="a2087c8ca2d04129a80a0b39586a2463d" name="a2087c8ca2d04129a80a0b39586a2463d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2087c8ca2d04129a80a0b39586a2463d">&#9670;&#160;</a></span>list_operators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DiracOperator::list_operators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List available operators. </p>

</div>
</div>
<a id="a2ccf497e09cf871508efa997fcc4d4ca" name="a2ccf497e09cf871508efa997fcc4d4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccf497e09cf871508efa997fcc4d4ca">&#9670;&#160;</a></span>MultipoleOperator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a> &gt; DiracOperator::MultipoleOperator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGrid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>low_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSphericalBessel_1_1JL__table.html">SphericalBessel::JL_table</a> *&#160;</td>
          <td class="paramname"><em>jl</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for relativistic multipole operators. </p>
<p>Constructs and returns a specific multipole operator derived from DiracOperator::TensorOperator, based on the requested Lorentz structure, multipole component, and momentum-transfer regime.</p>
<p>The operator corresponds to a spherical multipole of rank <code>k</code> with frequency/energy transfer <code>omega</code>. The type and component determine the Lorentz structure and spatial character of the interaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>Radial grid on which the operator acts. </td></tr>
    <tr><td class="paramname">k</td><td>Multipole rank (total angular momentum of the operator). </td></tr>
    <tr><td class="paramname">omega</td><td>Energy (frequency) transfer. </td></tr>
    <tr><td class="paramname">type</td><td>Interaction type:<ul>
<li>'V' : Vector</li>
<li>'A' : Axial-vector</li>
<li>'S' : Scalar</li>
<li>'P' : Pseudoscalar </li>
</ul>
</td></tr>
    <tr><td class="paramname">comp</td><td>Multipole component (for V/A types):<ul>
<li>'E' : Electric</li>
<li>'M' : Magnetic</li>
<li>'L' : Longitudinal</li>
<li>'T' : Temporal [caution - NOT transverse!] (Ignored for scalar and pseudoscalar operators.) </li>
</ul>
</td></tr>
    <tr><td class="paramname">low_q</td><td>If true, construct the low-momentum (long-wavelength) approximation of the operator. </td></tr>
    <tr><td class="paramname">jl</td><td>Optional pointer to a precomputed spherical Bessel table. If provided, radial Bessel functions are taken from this table to avoid recomputation. If nullptr, they are generated internally as needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::unique_ptr to the requested TensorOperator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Length-form electric operators (if implemented separately) are only valid for vector-electric ('V','E') combinations.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Invalid combinations of <code>type</code> and <code>comp</code> may result in a nullptr being returned. </dd></dl>

</div>
</div>
<a id="aeed793d98abb51ccddabee6bdcabb108" name="aeed793d98abb51ccddabee6bdcabb108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed793d98abb51ccddabee6bdcabb108">&#9670;&#160;</a></span>Pab() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DiracOperator::Pab </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pab function: Int[ (fa*gb + pm*ga*fb) * t(r) , dr]. pm = +/-1 (usually) </p>
<p>Note: does not know selection rules, so only evaluate if non-zero </p>

</div>
</div>
<a id="a4e3e332040b784e97460e6b65890de73" name="a4e3e332040b784e97460e6b65890de73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3e332040b784e97460e6b65890de73">&#9670;&#160;</a></span>Rab() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DiracOperator::Rab </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rab function: Int[ (fa*fb + pm*ga*gb) * t(r) , dr]. pm = +/-1 (usually) </p>
<p>Note: does not know selection rules, so only evaluate if non-zero </p>

</div>
</div>
<a id="a0258429af93c59907b247ce777d6f92e" name="a0258429af93c59907b247ce777d6f92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0258429af93c59907b247ce777d6f92e">&#9670;&#160;</a></span>Pab_rhs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DiracOperator::Pab_rhs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDiracSpinor.html">DiracSpinor</a> *&#160;</td>
          <td class="paramname"><em>dF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>A</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pab_rhs function: dF_ab += A * t(r) * (g, pm*f) , pm=+/-1 (usually). NOTE: uses +=, so can combine. Ensure empty to begin. </p>
<p>Note: does not know selection rules, so only evaluate if non-zero. Should have Fa*Pab_rhs = A * Pab. </p>

</div>
</div>
<a id="a8ae265f3305c4912b1f4764eeac57d81" name="a8ae265f3305c4912b1f4764eeac57d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae265f3305c4912b1f4764eeac57d81">&#9670;&#160;</a></span>Rab_rhs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DiracOperator::Rab_rhs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDiracSpinor.html">DiracSpinor</a> *&#160;</td>
          <td class="paramname"><em>dF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>A</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rab_rhs function: dF_ab += A * t(r) * (f, pm*g) , pm=+/-1 (usually). NOTE: uses +=, so can combine. Ensure empty to begin. </p>
<p>Note: does not know selection rules, so only evaluate if non-zero. Should have Fa*Rab_rhs = A * Rab. </p>

</div>
</div>
<a id="a0428c4d99942d7ec8dffb17016029730" name="a0428c4d99942d7ec8dffb17016029730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0428c4d99942d7ec8dffb17016029730">&#9670;&#160;</a></span>Vab()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DiracOperator::Vab </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vab function: Int[ (fa*gb ) * t(r) , dr]. </p>

</div>
</div>
<a id="a75c18225f0680e3d96d5f68ff44e3b47" name="a75c18225f0680e3d96d5f68ff44e3b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c18225f0680e3d96d5f68ff44e3b47">&#9670;&#160;</a></span>Wab()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DiracOperator::Wab </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wab function: Int[ (ga*fb ) * t(r) , dr]. </p>

</div>
</div>
<a id="a051262ad405cf60f7cf91799957c1709" name="a051262ad405cf60f7cf91799957c1709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051262ad405cf60f7cf91799957c1709">&#9670;&#160;</a></span>Gab() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DiracOperator::Gab </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gab function: Int[ (ga*gb ) * t(r) , dr]. </p>

</div>
</div>
<a id="adc984427efaa054d9e690001b9540ee4" name="adc984427efaa054d9e690001b9540ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc984427efaa054d9e690001b9540ee4">&#9670;&#160;</a></span>Gab() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DiracOperator::Gab </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gab = Int[ ga*gb , dr] - (just relativistic correction part of integral) </p>

</div>
</div>
<a id="ab170f4179f93e0aedc634775ed2ac2f7" name="ab170f4179f93e0aedc634775ed2ac2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab170f4179f93e0aedc634775ed2ac2f7">&#9670;&#160;</a></span>Gab_rhs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DiracOperator::Gab_rhs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDiracSpinor.html">DiracSpinor</a> *&#160;</td>
          <td class="paramname"><em>dF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gab_rhs(r) += a*g_b(r). Note: uses += so may be sumulative. </p>

</div>
</div>
<a id="a324ff3ab6167f95c6f65bbcc97a628de" name="a324ff3ab6167f95c6f65bbcc97a628de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324ff3ab6167f95c6f65bbcc97a628de">&#9670;&#160;</a></span>Pab() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DiracOperator::Pab </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pab[1] function: Int[ (fa*gb + pm*ga*fb) , dr]. pm = +/-1 (usually) </p>

</div>
</div>
<a id="a505727251d4b9f7d58eb19c3bc49893d" name="a505727251d4b9f7d58eb19c3bc49893d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505727251d4b9f7d58eb19c3bc49893d">&#9670;&#160;</a></span>Rab() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DiracOperator::Rab </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rab[1] function: Int[ (fa*fb + pm*ga*gb) , dr] = Int[ (pm-1)*ga*gb) , dr]. NOTE: assumes NOT diagonal, using orthogonality condition. </p>

</div>
</div>
<a id="a4b31c03717c41f3757000dfb9046c7af" name="a4b31c03717c41f3757000dfb9046c7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b31c03717c41f3757000dfb9046c7af">&#9670;&#160;</a></span>Pab_rhs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DiracOperator::Pab_rhs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDiracSpinor.html">DiracSpinor</a> *&#160;</td>
          <td class="paramname"><em>dF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pab_rhs[1] function: dF_ab += A * (g, pm*f) , pm=+/-1 (usually). </p>

</div>
</div>
<a id="ae77eb511ecedb2004e69bc0985a5bdbd" name="ae77eb511ecedb2004e69bc0985a5bdbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77eb511ecedb2004e69bc0985a5bdbd">&#9670;&#160;</a></span>Rab_rhs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DiracOperator::Rab_rhs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDiracSpinor.html">DiracSpinor</a> *&#160;</td>
          <td class="paramname"><em>dF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDiracSpinor.html">DiracSpinor</a> &amp;&#160;</td>
          <td class="paramname"><em>Fb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rab_rhs[1] function: dF_ab += A * (f, pm*g) = dF_ab += A * (0, (pm-1)*g). NOTE: assumes NOT diagonal, using orthogonality condition. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a8c816ffb9c46966c395c65f1fe1ae815" name="a8c816ffb9c46966c395c65f1fe1ae815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c816ffb9c46966c395c65f1fe1ae815">&#9670;&#160;</a></span>vec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">brief i DiracOperator::vec</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{\alpha} matrix element: propto Electric dipole <span class="keyword">operator</span>.</div>
<div class="line">    i factored so that ME is real</div>
<div class="line"><span class="keyword">class </span>ialpha final : <span class="keyword">public</span> <a class="code hl_class" href="classDiracOperator_1_1TensorOperator.html">TensorOperator</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  ialpha() : <a class="code hl_class" href="classDiracOperator_1_1TensorOperator.html">TensorOperator</a>(1, Parity::odd, 1.0, {}, 0, Realness::real, <span class="keyword">true</span>) {}</div>
<div class="line"> </div>
<div class="line">  std::string <a class="code hl_function" href="classDiracOperator_1_1TensorOperator.html#a6094da32309237c6f652e16ea8399ff4">name</a>() const override final { <span class="keywordflow">return</span> <span class="stringliteral">&quot;i*alpha&quot;</span>; }</div>
<div class="line">  std::string <a class="code hl_function" href="classDiracOperator_1_1TensorOperator.html#a33a42bfbe111a93375d5b819b08b5edc">units</a>() const override final { <span class="keywordflow">return</span> <span class="stringliteral">&quot;au&quot;</span>; }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> <a class="code hl_function" href="classDiracOperator_1_1TensorOperator.html#a4ac744208bd4bd5445e10414abbd5af0">angularF</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> ka, <span class="keyword">const</span> <span class="keywordtype">int</span> kb) <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span> {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceAngular.html#afd4880892614bcdd46cb181ad0e48384">Angular::Ck_kk</a>(1, ka, kb);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> angularCff(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>) <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span> { <span class="keywordflow">return</span> 0; }</div>
<div class="line">  <span class="keywordtype">double</span> angularCgg(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>) <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span> { <span class="keywordflow">return</span> 0; }</div>
<div class="line">  <span class="keywordtype">double</span> angularCfg(<span class="keywordtype">int</span> ka, <span class="keywordtype">int</span> kb) <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span> { <span class="keywordflow">return</span> ka - kb - 1; }</div>
<div class="line">  <span class="keywordtype">double</span> angularCgf(<span class="keywordtype">int</span> ka, <span class="keywordtype">int</span> kb) <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span> { <span class="keywordflow">return</span> ka - kb + 1; }</div>
<div class="line">}</div>
<div class="ttc" id="aclassDiracOperator_1_1TensorOperator_html"><div class="ttname"><a href="classDiracOperator_1_1TensorOperator.html">DiracOperator::TensorOperator</a></div><div class="ttdoc">General operator (virtual base class); operators derive from this.</div><div class="ttdef"><b>Definition</b> TensorOperator.hpp:110</div></div>
<div class="ttc" id="aclassDiracOperator_1_1TensorOperator_html_a33a42bfbe111a93375d5b819b08b5edc"><div class="ttname"><a href="classDiracOperator_1_1TensorOperator.html#a33a42bfbe111a93375d5b819b08b5edc">DiracOperator::TensorOperator::units</a></div><div class="ttdeci">virtual std::string units() const</div><div class="ttdoc">Returns units of operator (usually au, may be MHz, etc.)</div><div class="ttdef"><b>Definition</b> TensorOperator.hpp:186</div></div>
<div class="ttc" id="aclassDiracOperator_1_1TensorOperator_html_a4ac744208bd4bd5445e10414abbd5af0"><div class="ttname"><a href="classDiracOperator_1_1TensorOperator.html#a4ac744208bd4bd5445e10414abbd5af0">DiracOperator::TensorOperator::angularF</a></div><div class="ttdeci">virtual double angularF(const int, const int) const =0</div><div class="ttdoc">angularF: links radiation integral to RME. RME = &lt;a||h||b&gt; = angularF(a,b) * radial_int(a,...</div></div>
<div class="ttc" id="aclassDiracOperator_1_1TensorOperator_html_a6094da32309237c6f652e16ea8399ff4"><div class="ttname"><a href="classDiracOperator_1_1TensorOperator.html#a6094da32309237c6f652e16ea8399ff4">DiracOperator::TensorOperator::name</a></div><div class="ttdeci">virtual std::string name() const</div><div class="ttdoc">Returns &quot;name&quot; of operator (e.g., 'E1')</div><div class="ttdef"><b>Definition</b> TensorOperator.hpp:184</div></div>
<div class="ttc" id="anamespaceAngular_html_afd4880892614bcdd46cb181ad0e48384"><div class="ttname"><a href="namespaceAngular.html#afd4880892614bcdd46cb181ad0e48384">Angular::Ck_kk</a></div><div class="ttdeci">double Ck_kk(int k, int ka, int kb)</div><div class="ttdoc">Reduced (relativistic) angular ME: &lt;ka||C^k||kb&gt; [takes k and kappa].</div><div class="ttdef"><b>Definition</b> Wigner369j.hpp:306</div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceDiracOperator.html">DiracOperator</a></li>
    <li class="footer">Generated on Mon Mar 2 2026 04:48:12 for ampsci by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
